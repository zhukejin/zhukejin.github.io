{"meta":{"title":"凤歌笑孔丘","subtitle":null,"description":null,"author":"Primo","url":"https://zhukejin.com","root":"/"},"pages":[{"title":"","date":"un00fin00","updated":"un00fin00","comments":true,"path":"404.html","permalink":"https://zhukejin.com/404.html","excerpt":"","text":"Document"},{"title":"","date":"un33fin33","updated":"un00fin00","comments":false,"path":"about/index.html","permalink":"https://zhukejin.com/about/index.html","excerpt":"","text":"我本楚狂人，凤歌笑孔丘"},{"title":"","date":"un33fin33","updated":"un00fin00","comments":false,"path":"categories/index.html","permalink":"https://zhukejin.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"un33fin33","updated":"un00fin00","comments":false,"path":"tags/index.html","permalink":"https://zhukejin.com/tags/index.html","excerpt":"","text":""},{"title":"友情链接","date":"un00fin00","updated":"un00fin00","comments":true,"path":"links/index.html","permalink":"https://zhukejin.com/links/index.html","excerpt":"","text":""}],"posts":[{"title":"typescript-infer","slug":"typescript-infer","date":"un44fin44","updated":"un55fin55","comments":true,"path":"2023/typescript-infer/","permalink":"https://zhukejin.com/2023/typescript-infer/","excerpt":"介绍111TypeScript是一种静态类型检查器，它可以识别代码中的错误并提供更好的代码提示。它是JavaScript的超集，可以使代码更加健壮和易于维护。在TypeScript 2.8版本中，引入了一个新的关键字“infer”。这个关键字可以帮助我们从函数返回的类型中推断出参数的类型。 Infer的用法Infer关键字通常与条件类型一起使用。条件类型是一种新的类型语法，它允许根据类型关系的真实性来选择不同的类型。它的语法是“T extends U ? X : Y”。如果T可以赋值给U，那么这个类型为X，否则为Y。 Infer关键字可以用在条件类型中，用于从函数返回的类型中推断出参数的类型。例如，我们可以使用Infer关键字来推断函数的第一个参数的类型。这个参数是一个函数，它返回一个类型。 12type ReturnType&lt;T&gt; = T extends (...args: any[]) =&gt; infer R ? R : any;","text":"介绍111TypeScript是一种静态类型检查器，它可以识别代码中的错误并提供更好的代码提示。它是JavaScript的超集，可以使代码更加健壮和易于维护。在TypeScript 2.8版本中，引入了一个新的关键字“infer”。这个关键字可以帮助我们从函数返回的类型中推断出参数的类型。 Infer的用法Infer关键字通常与条件类型一起使用。条件类型是一种新的类型语法，它允许根据类型关系的真实性来选择不同的类型。它的语法是“T extends U ? X : Y”。如果T可以赋值给U，那么这个类型为X，否则为Y。 Infer关键字可以用在条件类型中，用于从函数返回的类型中推断出参数的类型。例如，我们可以使用Infer关键字来推断函数的第一个参数的类型。这个参数是一个函数，它返回一个类型。 12type ReturnType&lt;T&gt; = T extends (...args: any[]) =&gt; infer R ? R : any; 在这个例子中，ReturnType类型接受一个泛型参数T，它是一个函数类型。如果T可以赋值给一个接受任何参数并返回一个类型的函数，那么ReturnType类型就会返回这个函数的返回类型。 Infer的实际应用Infer关键字的一个实际应用是在React中使用HOC（高阶组件）。HOC是一个返回新组件的函数，这个组件可以包装其他组件，从而提供一些通用的行为或状态。通常情况下，HOC会接受一个组件作为参数，并返回一个新的组件。 jsx12345678910function withLoading&lt;P&gt;(Component: React.ComponentType&lt;P&gt;) &#123; return function WithLoading(props: P &amp; &#123; isLoading: boolean &#125;) &#123; const &#123; isLoading, ...rest &#125; = props; if (isLoading) &#123; return &lt;div&gt;Loading...&lt;/div&gt; &#125; return &lt;Component &#123;...rest&#125; /&gt; &#125;&#125; 在这个例子中，我们定义了一个名为withLoading的函数，它接受一个React组件作为参数，并返回一个新的组件。这个新组件会在组件渲染之前检查isLoading属性。如果isLoading属性为真，它会显示一个“Loading…”文本，否则将渲染原始组件。 在这个例子中，我们使用了Infer关键字来推断原始组件的属性类型。我们可以通过以下方式使用withLoading函数： jsx123456type Props = &#123; name: string, age: number &#125;;const MyComponent = (&#123; name, age &#125;: Props) =&gt; &#123; return &lt;div&gt;&#123;name&#125;, &#123;age&#125;&lt;/div&gt;;&#125;;const MyComponentWithLoading = withLoading(MyComponent); 在这个例子中，我们定义了一个名为MyComponent的组件，它接受两个属性：name和age。我们使用MyComponentWithLoading来包装MyComponent，并将其赋值给一个新的变量。在这个过程中，我们使用了Infer关键字来推断MyComponent的属性类型。 总结Infer关键字是TypeScript 2.8中一个非常有用的特性。它可以帮助我们从函数返回的类型中推断参数的类型，并使我们的代码更加健壮和易于维护。在实际应用中，我们可以使用它来推断组件的属性类型，并在高阶组件中使用它来增强组件的功能。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhukejin.com/categories/JavaScript/"}],"tags":[{"name":"Typescript","slug":"Typescript","permalink":"https://zhukejin.com/tags/Typescript/"}]},{"title":"浏览器端获取当前执行js的文件名","slug":"浏览器端获取当前执行js的文件名","date":"un55fin55","updated":"un00fin00","comments":true,"path":"2023/浏览器端获取当前执行js的文件名/","permalink":"https://zhukejin.com/2023/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%AB%AF%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E6%89%A7%E8%A1%8Cjs%E7%9A%84%E6%96%87%E4%BB%B6%E5%90%8D/","excerpt":"今天有人问我 js 在浏览器执行中怎么获取当前执行文件名？ 我第一反应就是用 activeX。但转念一想，这都2023年了， IE 都噶了，还用个篮子的 activeX。 那就再反应一次: “Error Stack”","text":"今天有人问我 js 在浏览器执行中怎么获取当前执行文件名？ 我第一反应就是用 activeX。但转念一想，这都2023年了， IE 都噶了，还用个篮子的 activeX。 那就再反应一次: “Error Stack” 具体实现实现起来也比较简单 12345678910111213function getCurrentScriptFileName() &#123; // 创建一个 Error 对象 const error = new Error(); // 获取调用栈信息 const stack = error.stack; console.trace(stack) // 在栈信息中查找当前正在执行的脚本文件名 const matchResult = stack.match(/(http|https):\\/\\/[^\\n]+\\.js/); // 返回匹配结果 return matchResult ? matchResult[0] : &#x27;&#x27;;&#125; 执行效果写一个小 demo 试试 12345&lt;body&gt;&lt;script src=&quot;./zz.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;./bb.js&quot;&gt;&lt;/script&gt;&lt;/body&gt; 1234567891011121314151617181920// zzfunction main() &#123; const filename = getCurrentScriptFileName() console.log(&#x27;file is : &#x27;, filename)&#125;function getCurrentScriptFileName() &#123; // 创建一个 Error 对象 const error = new Error(); // 获取调用栈信息 const stack = error.stack; console.trace(stack) // 在栈信息中查找当前正在执行的脚本文件名 const matchResult = stack.match(/(http|https):\\/\\/[^\\n]+\\.js/); // 返回匹配结果 return matchResult ? matchResult[0] : &#x27;&#x27;;&#125; 12// bbmain() 浏览器打印结果： 123456789Error at getCurrentScriptFileName (http://localhost:63342/test/zz.js:10:19) at main (http://localhost:63342/test/zz.js:3:22) at http://localhost:63342/test/bb.js:1:1getCurrentScriptFileName @ zz.js:14main @ zz.js:3(anonymous) @ bb.js:1file is : http://localhost:63342/test/zz.js 收尾妙啊~","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhukejin.com/categories/JavaScript/"}],"tags":[]},{"title":"自动创建 GitLab Merge Request","slug":"自动创建-GitLab-Merge-Request","date":"un44fin44","updated":"un00fin00","comments":true,"path":"2023/自动创建-GitLab-Merge-Request/","permalink":"https://zhukejin.com/2023/%E8%87%AA%E5%8A%A8%E5%88%9B%E5%BB%BA-GitLab-Merge-Request/","excerpt":"最近规范代码提交流程，所有提交必须走 GitLab 的 Merge Request。所以就很烦，每一个功能改动都要提交三份 MR（test&#x2F;uat&#x2F;master），一系列操作下来，人都麻了…此时就要祭出杀器 Python大法","text":"最近规范代码提交流程，所有提交必须走 GitLab 的 Merge Request。所以就很烦，每一个功能改动都要提交三份 MR（test&#x2F;uat&#x2F;master），一系列操作下来，人都麻了…此时就要祭出杀器 Python大法 库选择站在巨人的肩膀上 目前有一个现成的库： python-gitlab 实现方式 选择代码库 选择项目 使用传入的参数创建 MR 添加命令行快捷指令 具体实现工具文件辅助工具，获取当前工作空间中的git 分支名称，用来快速合并分支用。 1234567891011import subprocessdef get_git_branch(folder_path): try: process = subprocess.Popen([&quot;git&quot;, &quot;-C&quot;, folder_path, &quot;rev-parse&quot;, &quot;--abbrev-ref&quot;, &quot;HEAD&quot;], stdout=subprocess.PIPE) branch_name = process.stdout.read().strip().decode(&#x27;utf-8&#x27;) return branch_name except: return None 主文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# -*- coding: utf-8 -*-import gitlabimport argparsefrom get_git_branch import get_git_branchdef main(): # 定义命令行参数 parser = argparse.ArgumentParser(description=&quot;Create a merge request using python-gitlab&quot;) parser.add_argument(&quot;-s&quot;, &quot;--source&quot;, help=&quot;Source branch&quot;) # parser.add_argument(&quot;target_branch&quot;, help=&quot;Target branch&quot;) parser.add_argument(&quot;-m&quot;, &quot;--title&quot;, help=&quot;Merge request title&quot;) # parser.add_argument(&quot;description&quot;, help=&quot;Merge request description&quot;) parser.add_argument(&quot;-t&quot;, &quot;--target&quot;, help=&quot;Merge target&quot;) args = parser.parse_args() # 连接 GitLab API gl = gitlab.Gitlab(url=&#x27;https://address.gitlab.com&#x27;, private_token=&#x27;my token&#x27;) # 选择项目 project = gl.projects.get(40) # 项目文件夹的当前分支 current_branch = get_git_branch(&#x27;当前的项目工作目录&#x27;) # 优先用传入的分支名 source_branch = args.source or current_branch if args.target is None: return print(&#x27;请输入目标分支，-t = test|uat|master|all, 可同时输入多个&#x27;) # 创建合并请求列表 target_branches = [&#x27;test&#x27;, &#x27;uat&#x27;, &#x27;master&#x27;] for target_branch in target_branches: if target_branch in args.target or &#x27;all&#x27; in args.target: merge_request = project.mergerequests.create(&#123; &quot;source_branch&quot;: source_branch, &quot;target_branch&quot;: target_branch, &quot;title&quot;: args.title, &quot;description&quot;: &quot;&quot; &#125;) print(f&quot;&#123;merge_request.target_branch&#125; Merge request created: &#123;merge_request.web_url&#125;&quot;)if __name__ == &#x27;__main__&#x27;: main() 用法1python3 main.py [-s xxx] -t xxx -m &quot;xxx&quot; 其中 -s 为可选，-t 为字符串，如果想发到哪个分支就包含哪些分支字符串，如 “test|uat”，或者使用 “all” 添加系统快捷指令(alias)通过 alias 添加快捷命令，以 zsh 为例，如果不知道这是啥，自行百度一下哈。 1234vim .zshrc# 加入一行alias cm=&quot;python3 /Users/zhukejin/work/tools/gitlab/main.py&quot; 用法1cm -t uat -m &quot;merge uat&quot; 完事手动 dog 更新：用了几天后，感觉少了点什么东西… 获取最近一次提交的 message新建辅助文件 get_git_message.py 123456import subprocessdef get_latest_commit_message(folder_path): result = subprocess.run([&quot;git&quot;, &quot;-C&quot;, folder_path, &quot;log&quot;, &quot;-1&quot;, &quot;--pretty=%B&quot;], stdout=subprocess.PIPE) return result.stdout.decode(&quot;utf-8&quot;) 主文件中引入此方法，并添加逻辑： 12345678910111213# 最后一次提交的 messagemessage =args.title or get_latest_commit_message(work_path)......merge_request = project.mergerequests.create(&#123; &quot;source_branch&quot;: source_branch, &quot;target_branch&quot;: target_branch, - &quot;title&quot;: args.title, + &quot;title&quot;: message, &quot;description&quot;: &quot;&quot;&#125;) 这样每次连 ‘-t xxx’ 都不用写了（前提是git message 提交要规范） 添加二次确认因为执行后就直接提交了， 万一写错了怎么办？很慌。 123456789101112131415161718192021222324# 添加二次确认 user_input = input(f&#x27;&#x27;&#x27;提交信息为：source: &#123;source_branch&#125;target: &#123;args.target&#125;message: &#123;message&#125;是否确认提交 MR？请输入 y/n ?&#x27;&#x27;&#x27;)if user_input.lower() == &#x27;y&#x27;: for target_branch in target_branches: if target_branch in args.target or &#x27;all&#x27; in args.target: merge_request = project.mergerequests.create(&#123; &quot;source_branch&quot;: source_branch, &quot;target_branch&quot;: target_branch, &quot;title&quot;: message, &quot;description&quot;: &quot;&quot; &#125;) print(f&quot;&#123;merge_request.target_branch&#125; Merge request created: &#123;merge_request.web_url&#125;&quot;)else: print(&quot;取消提交&quot;) 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475# -*- coding: utf-8 -*-import gitlabimport argparsefrom get_git_branch import get_git_branchfrom get_git_message import get_latest_commit_messagework_path = &#x27;/Users/work/lbank-front&#x27;def main(): # 定义命令行参数 parser = argparse.ArgumentParser(description=&quot;Create a merge request using python-gitlab&quot;) # parser.add_argument(&quot;private_token&quot;, help=&quot;GitLab private token&quot;) # parser.add_argument(&quot;project_id&quot;, help=&quot;Project ID&quot;) parser.add_argument(&quot;-s&quot;, &quot;--source&quot;, help=&quot;Source branch&quot;) # parser.add_argument(&quot;target_branch&quot;, help=&quot;Target branch&quot;) parser.add_argument(&quot;-m&quot;, &quot;--title&quot;, help=&quot;Merge request title&quot;) # parser.add_argument(&quot;description&quot;, help=&quot;Merge request description&quot;) parser.add_argument(&quot;-t&quot;, &quot;--target&quot;, help=&quot;Merge target&quot;) args = parser.parse_args() # 连接 GitLab API gl = gitlab.Gitlab(url=&#x27;https://gitlab.ex.com/&#x27;, private_token=&#x27;xxx&#x27;) # 选择项目, 这里要看一下项目id 是什么 project = gl.projects.get(40) # lbank-front 文件夹的当前分支 current_branch = get_git_branch(work_path) # 优先用传入的分支名 source_branch = args.source or current_branch # 最后一次提交的 message message =args.title or get_latest_commit_message(work_path) if args.target is None: return print(&#x27;请输入目标分支，-t = test|uat|master|all, 可同时输入多个&#x27;) # 创建合并请求列表 target_branches = [&#x27;test&#x27;, &#x27;uat&#x27;, &#x27;master&#x27;] # 命令行确认 user_input = input(f&#x27;&#x27;&#x27;提交信息为：source: &#123;source_branch&#125;target: &#123;args.target&#125;message: &#123;message&#125;是否确认提交 MR？请输入 y/n ?&#x27;&#x27;&#x27;) if user_input.lower() == &#x27;y&#x27;: for target_branch in target_branches: if target_branch in args.target or &#x27;all&#x27; in args.target: merge_request = project.mergerequests.create(&#123; &quot;source_branch&quot;: source_branch, &quot;target_branch&quot;: target_branch, &quot;title&quot;: message, &quot;description&quot;: &quot;&quot; &#125;) print(f&quot;&#123;merge_request.target_branch&#125; Merge request created: &#123;merge_request.web_url&#125;&quot;) else: print(&quot;&quot;)if __name__ == &#x27;__main__&#x27;: main()","categories":[{"name":"Python","slug":"Python","permalink":"https://zhukejin.com/categories/Python/"}],"tags":[{"name":"Tool","slug":"Tool","permalink":"https://zhukejin.com/tags/Tool/"}]},{"title":"2022 知识图谱整理","slug":"knowledge-map","date":"un22fin22","updated":"un00fin00","comments":true,"path":"2022/knowledge-map/","permalink":"https://zhukejin.com/2022/knowledge-map/","excerpt":"梳理了一些知识图谱~","text":"梳理了一些知识图谱~ 概览 详细描述JavaScript 基础 原型与原型链 new 操作符 在内存中创建一个新对象 将对象内部的__proto__ 赋值为构造函数的 prototype 属性（原型链挂载） 将构造函数的this 指向新对象(this 绑定) 执行构造函数的代码 this 指向问题 核心: 谁调用就指向谁 方法调用的时候， this 指向指向方法所在的对象。 当没有明确调用方的时候，this 就指向window，比如 setTimout 这种异步函数、匿名函数 箭头函数比较特殊，它在经过 babel 编译后，会用 _this 记录定义时候的this 对象，来实现一个固定this 的效果。 call&#x2F;bind&#x2F;apply 这三个都是改变this 指向的方法。 call、apply 几乎完全一样，只有第二个参数类型的区别。call 是多个参数传递，apply 是多个参数组成一个数组参数传递。 bind 更类似于函数的延迟调用，传入一个作用域后返回一个新的函数，在调用新函数的时候传入对应参数。 闭包 闭包 &#x3D;『函数』和『函数体内可访问的变量总和』 核心： 当一个变量被内部函数使用的时候，就产生了一个闭包。 一般用途：存储一些内部变量，如 ts 编译私有变量， 就是通过闭包实现的。 缺点：内存常驻，无法通过GC 回收。 柯里化可以理解为闭包的进阶用法，利用闭包和 apply&#x2F;call 来达到延迟调用的目的。一般用于函数式库中的链式调用 如 lodash fp 中 sum(2)(3) &#x3D; 5 事件循环 JavaScript 是单线程，非阻塞式的语言，为了实现非阻塞式的异步编程，就需要事件循环机制来处理任务。 在一次完整的JavaScript任务中，分为 同步任务和异步任务，异步任务又分为宏任务和微任务。 微任务优先级略微高点的异步任务，在同步任务执行完毕后，优先执行，代表如 promise.then 、mutationObserver 等 宏任务在执行栈最底部调用，代表如 setTimeout、setInterval、IO 操作、UI 操作等。 Node 中的事件循环 Node 的事件循环和浏览器中的事件循环是两个不同的机制，它分为6个阶段，分别是 Timer， 执行到期的 setTimeout、setInterval 回调 IO 阶段，主要处理上一次循环残留的 callback idle 阶段 poll： 等待回调 执行回调 执行定时器 如果有到期的 setTimeout、setInterval，返回 Timer 阶段 如果有 setImmediate，则前往 check 阶段 check 执行 setImmediate 的callback close callbacks 执行一些close 的回调， 比如 server.close、socket.close 关键帧回调 requestAnimationFrame多用于动画帧处理，在浏览器每次刷新的时候调用，以达到更流畅的动画效果 requestIdleCallBack在 React 的Fiber 架构中，有个任务调度的概念，这个方法就类似于 Fiber 任务调度如果硬件配置比较高，浏览器在执行完一帧任务后，会有一定的空闲时间，这个时间就可以通过 requestIdleCallBack 去调用，从而来实现 空闲时执行任务的目的，它不会影响主线程执行。 V8 的垃圾回收策略分代式垃圾回收机制，根据对象的存活时间将内存的垃圾回收进行不同的分代，然后对不同分代采用不同的垃圾回收算法新生代： 用于存放存活时间比较短的对象。再将新生代内存空间细分为两个空间 From 和 To，在程序执行过程中，会对From 空间的数据进行检查，如果发现有对象没有被使用（失活），就将此对象赋值到 To 空间中，如果有对象没有被其他地方引用，则对其进行垃圾回收（清除From），至此第一次线程任务执行完毕，From 和 To 完成身份互换。 在第二次任务执行的时候，重复上述操作，回收失活对象。老生代： 当一个数据在 From、To 中完整的转移一次后，会认为是生命周期比较长的对象，在下一次垃圾回收的时候，会将其存储到老生代内存中（晋升） 老生代的算法有所变更，会采用 标记清除和标记整理 的方式来进行管理。垃圾回收器会基于 window 去遍历可访问的子节点，然后将这些节点标记为活动节点。如果发现某些属性不能访问或者无法遍历（失去作用域链），就对其进行垃圾回收。 ES6、ES7 let、const let、const 和var 的区别就在于他们俩不会变量提升，只会有一个暂存死区（在预编译阶段实现） Promise 简单点讲就是在构造函数执行的时候，对 .then 中的回调进行收集，存储到内部维护的 _callback 数组中，在执行 resolve 的时候循环调用回调。 同时在内部维护三个状态 Pending rejected fulfilled, 用来控制任务状态。 Async、Await 可以理解为 promise 的同步语法糖，可通过 async await 将 promise 转变成同步写法（实际还是异步）。 在通过 babel 编译后，具体会通过 while 循环来实现。 Proxy Vue3 的核心监听方法就是通过 Proxy 来实现的， 可以监听一个 target，并绑定一个handle 对象，handle 对象中有 set、get 属性。 Symbol 模块化 AMD requireJS 的默认加载规范，主要特征为依赖前置，在执行前就将依赖都加载完毕。 CMD seaJS 提出的加载规范，主要特征为随用随加载（依赖就近原则）。 UMD CommonJS Nodejs 的模块规范，一个单独的文件就是一个模块，加载的时候使用 require() 来加载，返回内部的 exports 对象 ES6 Module 跨页面通讯 postMessage serviceWorker Vue2 基本原理 基于发布订阅者模式以及观察者模式 双向绑定原理Vue2 中通过 defineProperty 来监听 options.data 中的数据，为数据添加 getter&#x2F;setter，使其变成响应式数据。当用户访问、修改响应式数据的时候，就会被拦截器拦截，从而进行后续的操作，如 watcher、dep 变更、diff 以及 patch。但是同时也存在一些问题，defineProperty 无法拦截到数组的原型链操作，如push、slice，或者对象的 delete 操作符，vue2 通过原型方法重新的方式来解决这些问题。当然好处就是兼容性好，支持到 IE8+。 Observe监听者，即内部通过 defineProperty来实现数据监听的一个函数。 Dep为发布订阅模式中的，订阅器，主要用于保存订阅者。Vue 会为每个属性绑定上监视器，当属性值被修改的时候（触发 setter&#x2F;set），就触发该值对应的 Dep.notify 来通知 subs(订阅者数组，由多个 Watcher 订阅者组成的数组)， Watcher观察者，也是发布订阅模式中的订阅者。每个Vue 实例都会创建一个 Watcher 对象，Watcher负责接受 Dep 对象的变化，并且触发 re-render。 依赖收集Dep 收集Watcher 到subs，并存储到每个响应式数据中的这个过程就叫做依赖收集 虚拟DOMVue2 采用了和 React 类似的虚拟Dom，一个虚拟DOM 就是包含了tag 信息、属性信息、依赖事件、子节点、父节点、兄弟节点的对象。虚拟Dom 的优点是可以通过 Diff 计算差异，生成新的DOM 节点，随后进行一次性更新真实DOM，减少浏览器重排时间，进而提高性能。 AST 语法树Vue2 采用 .vue 模板形式开发，通过 vue-template-loader 来编译文件的同时，就可以生成 AST 语法树并分析数据依赖。所谓 AST 语法树则和 虚拟DOM比较类似，是一个树形的DOM 节点列表。 For Key为什么列表循环中需要Key？Vue 的 Diff算法 &amp; 就地复用策略决定。在 Diff 过程中，Vue 会对比 tag名称、属性等来判断节点是否更新，如果Key 存在的话，Vue 会优先使用 Key 进行判断，性能会好很多。 nextTick在下次dom 更新结束后执行延迟回调，内部采用微任务 &gt; 宏任务 来实现，优先通过 promise.then&#x2F;requestAnimateRequest 来做，如果不支持，则通过 setTimeout来实现。 Diff 算法 Vue2 采用基于深度遍历的查找算法，然后同层对比，在对比同层的时候，采用单循环双指针同层对比（头头尾尾头尾） 对比时优先对比Key，如果Key 相同则认为是同元素，不执行 update 操作。 如果没有key（非列表元素）则对比 tagName&#x2F;attrs&#x2F;class 等具体属性，有差异则在 vNode中标记 update。 keep-alive 原理 Vue3 基本原理 vue3 中使用了 Proxy 来代替 defineProperty，最直接的好处就是 proxy 可以直接监听一个对象，而非一个属性，并且可以监听到数组的原型方法。 proxy 中内置的拦截方法比较多， 基本可以满足所有拦截需求。 watch作用等同于 Vue2 的Watch，监听一个响应式数据，当此响应式数据发生变化的时候，触发对应的回调函数 watchEffectvue3 新增，区别于 watch，watch 是明确监听一个响应式数据，而 watchEffect 是隐式的监听内部数据，并且在初始化的时候就立即执行回调函数。更像 React 里面的 useEffect，一个副作用函数。 watchPostEffect在DOM 更新完成后执行。 reactiveVue3 的核心监听函数，内部会递归调用 new Proxy 将 data 数据转化为 proxy 对象 proxy 拦截器Vue3 在创建Proxy 时，对对象进行拦截，使用了 set&#x2F;get&#x2F;deleteProperty&#x2F;has&#x2F;ownKeys 拦截器保证可以监听到对象的各种操作 VueX Mobx React 基本原理 与Vue 的区别 基本原理不同：React 与 Vue 的设计思路不同，React 是Push 的方式去通知框架数据发生了变更，Vue 是通过依赖收集和双向绑定自动监听数据变化，从而通知DOM 更新。 DIFF 方式不同，React diff 采用的是fiber 加持下的单向链表依次对比，Vue 采用的是双向链表双指针头尾对比。 React 存在 fiber 的time slice 调度，vue 没有 Time Slice 时间切片，因为 JavaScript 单线程的局限性，为了尽可能提高用户的观感执行速度， React 将比较耗时的任务拆分为微小地执行单元，通过内部实现的调度算法来决定先执行哪些比较重要的任务块。 Fiber 架构 为了方便模拟JavaScript 调用栈，Fiber 提供了一种新的单向链表数据结构，用来替代原先的虚拟dom 节点 VNode，其中会包含一些节点信息、子节点信息、下一个节点信息，每个节点都是一个fiber 对象，模拟了调用栈帧后，方便在内存中记录执行状态，随时的中断或恢复 在以往的版本中，React 是一边Diff 一边提交更新，现在 Fiber 设计了两个阶段 Reconciliation 协调阶段此阶段可认为是 React 的Diff 阶段，此阶段会找出所有节点的变更，如节点的新增、删除、更新等，这些变更就被成为React 的副作用 (Effect)， 这个阶段会调用 constructor&#x2F;shouldComponentUpdate&#x2F;render 生命周期。 Commit 提交阶段首先将上个阶段的Effect 一次性执行，此阶段不能被中断，必须同步执行，会触发 componentDidMount&#x2F;componentDidUpdate&#x2F;componentWillUnmount 生命周期。 协调阶段如果时间片用完，React 会选择让出控制权，因为协调阶段做的事情不会导致用户可见的变更。 而Commit 阶段中，用户的副作用（逻辑）操作被认为是优先级最高的，所以必须同步一次性按顺序执行。 如何优化 React 使用 React.memo 来缓存组件 使用 useMemo、userCallback 来缓存大量计算 如果有必要，使用 React.PureComponent 来优化函数组件 PureComponent 会进行浅比较来判断是否更新组件，如果 Props 的值相同，就不会更新组件，节省一些开支。 避免使用内联对象，内联对象每次render 后都会创建一个新的引用地址，会被 React 认为是 props 更新。 尽可能少的使用匿名函数，原因同上。 对一些组件延迟加载，如使用 React.lazy() 使用 React.Fragment 来创建 Fiber 节点，而非Dom 元素 Angular 基本原理 不同于 Vue、React，Angular 继续使用 ng1 的数据脏检查来实现数据变动侦测，通过 zone.js 对一些用户关键操作，如setTimeout&#x2F;form change&#x2F;event 重写，在特定的时间遍历数据，检测哪些数据发生变化，并更新dom。 Angular 并没有像 Vue、React 一样采用虚拟Dom， 它使用了 WebComponent 中的 ShadowDOM 来做组件隔离和DOM 渲染 相比 React 的函数式设计思想、Vue 的组合式设计思想，Angular采用了传统的程序设计，采用了 数据模型、控制器、视图的结构划分，通过依赖注入来维护关系，内部深度依赖了 RX.js 来进行任务流编程。 依赖注入来自JAVA 的一种设计模式，在 Angular 中，通过 Typescript 的注解器来实现了 @Injection 方法，将模型传递给对应的被依赖的控制器。 AOT &amp; JITAngular 的编译模式，同样来自JAVA，分别为预先编译、运行时编译 Typescript 类型校验 装饰器 元编程 工具库 RxJS Lodash CSS 基础 选择器 盒模型 标准模型 怪异模型 BFC 自适应布局 Flex Sass Less 工程化 WebPack 构建流程 初始化参数 开始编译 从入口开始分析代码、加载文件 完成文件编译，执行插件 输出资源 Loader &amp; Plugins Loader 是文件加载所用，Plugins 是各种各样的插件 Rollup 摇树优化 Vite 前端优化 http 优化 代码压缩，减少体积 服务器开启 Gzip splitChunks 拆包，按需加载 图片使用内联或者雪碧图 开启http2 首部压缩 合理使用 http 缓存 使用 nginx 中间件，将多个请求合并 利用 CDN 加速 vender 交互优化 减少页面的重排 优化动画效果，减少用户等待感知 骨架屏优化 图片懒加载 前端安全 XSS 注入 即通过不安全的输入框、请求参数等，将攻击代码传输到服务器 一般情况下，后端框架会去做 xss 过滤校验，如果需要，前端可以在用户输入的地方进行一次前置性过滤 不过此方法依然不安全，前端代码是可见的，用户可任意篡改 CSRF 请求伪造 即攻击者通过使用用户cookie 模拟用户请求 服务器可每次生成一个 token，存储在 session 中，跟随每次请求返回，客户端在下次请求的时候将这个token 传递给后端校验，用过一次后失效，生成新的token 。 浏览器 页面加载过程 JavaScript 的预编译 重绘、重排浏览器在发现DOM 元素发生变化的时候会重新渲染。 当发现DOM 的空间属性发生变化（如 zIndex、显示隐藏、位置变化、大小变化）的时候，会引起 DOM 重排。 当发现 DOM 的颜色等不影响布局的属性发生变化时，会引起 DOM 重绘。 重排一定会引起重绘，重绘不会引起重排 缓存 强缓存如 Cache-Control&#x2F;Expires ，浏览器判断缓存是否过期，如果没有过期就直接使用缓存信息，不经过服务器确认。其中 Cache-Control 的 max-age 优先级高于 Expires。当发现缓存已过期的时候，就检查协商缓存。 协商缓存目前用的比较多的缓存策略，浏览器请求一次服务端，服务端返回对应的返回头，浏览器通过 header 信息来检查是否需要更新资源，常见的控制协商缓存的字段有： etag 优先级较高 if-none-match last-modified 最后修改时间，如果一致，服务端返回 304 if-modified-since 跨域 同源策略浏览器的安全策略决定只能同源进行post、put 等高危操作，如果发现不同源，则拦截该请求，这个策略即同源策略。 解决跨域 CORS在服务端设置请求头 access-control-allow-origin 白名单，如果设置为 * 则代表允许所有域请求。开启跨域后，需要设置 withCredentials 为 true ，cookie 才可以正常携带。 JSONP 很古老的技术，原理是通过get 请求一个script 脚本，返回一个函数，前端接收到后执行，因为get 请求没有跨域问题，基本淘汰。 网关代理 比较优雅的解决方案，通过网关代理，将不同域的请求转化为同域，以解决跨域。比如通过 nginx 中的 rewrite 转发。 在webpack dev 中的proxy 也是基于代理做的。 简单请求和复杂请求 请求方法为 GET、POST、HEAD，且请求头中只包含下列字段的请求，就叫做简单请求， Accept Accept-Language Content-Language Content-Type DPR Downlink Save-Data Viewport-Width Width Option 嗅探在跨域发出复杂请求前， 浏览器会触发一个 Option 类型的请求，用来鉴定是否可以正常通讯。 后端NodePython flask PHP CI lumen 通用Cookie &amp; Session网络协议 TCP 三次握手 客户端发送 syn请求，进入 syn_send 状态，等待确认 服务端接受到 syn 请求，发送 syn + ack 包，进入 syn_recv 状态 客户端接受到 syn+ack 后，发送 ack 包，双方建立连接 四次挥手 客户端发送 fin 给服务端，服务端进入 fin-wait 状态 服务端发送 ack 给客户端，进入 close-wait 状态 服务端发送 ack+fin 给客户端，进入last-act 状态 客户端 发送 act 给服务端，进入 closed，关闭连接 UDP和 TCP 相比，UDP 是一种无连接协议，不需要建立链接的单向发送包，不需要维护状态，比如实时语音聊天 HTTP 状态码 200 成功 301 永久重定向 302 临时重定向 304 资源未修改，使用缓存 400 请求错误 401 需要认证 403 权限问题，拒绝请求 404 不存在 500 服务器错误 502 网关错误 504 超时 HTTP 2.0新增了多路复用、首部压缩、服务端推送。 HTTPS网关设置端口为 443，并且配置 SSL 公钥证书，优点是会进行隧道加密。 Rest API常见的的Rest 请求类型分为 get post put patch delete 其中 get、put、delete 都应该是幂等操作 设计模式 工厂模式 代理模式 观察者模式 算法 DFS深度优先算法，Vue、React 的Diff 查找中都使用此算法，在遍历的时候优先查找一个分支，当最终节点没有子节点的时候，重新返回父级查找兄弟节点。 BFS广度优先算法","categories":[{"name":"Other","slug":"Other","permalink":"https://zhukejin.com/categories/Other/"}],"tags":[]},{"title":"JavaScript 反射元编程","slug":"typescript-reflect","date":"un55fin55","updated":"un00fin00","comments":true,"path":"2022/typescript-reflect/","permalink":"https://zhukejin.com/2022/typescript-reflect/","excerpt":"概念什么是反射？ 在计算机学中，反射式编程（英语：reflective programming）或反射（英语：reflection），是指计算机程序在运行时（runtime）可以访问、检测和修改它本身状态或行为的一种能力。[1]用比喻来说，反射就是程序在运行的时候能够“观察”并且修改自己的行为。 – 来自维基百科 反射就是指程序运行阶段(RunTime)拦截程序，以达到获取、修改自身元数据的目的。这在其他高级语言中是非常常见的概念。 在JavaScript 这种动态语言中，反射可以说是无处不在。 我们随时可以去新增、修改对象的属性，甚至可以重新定义对象中的方法，如我们日常使用的 apply 、 defineProperty 操作就属于典型的反射。","text":"概念什么是反射？ 在计算机学中，反射式编程（英语：reflective programming）或反射（英语：reflection），是指计算机程序在运行时（runtime）可以访问、检测和修改它本身状态或行为的一种能力。[1]用比喻来说，反射就是程序在运行的时候能够“观察”并且修改自己的行为。 – 来自维基百科 反射就是指程序运行阶段(RunTime)拦截程序，以达到获取、修改自身元数据的目的。这在其他高级语言中是非常常见的概念。 在JavaScript 这种动态语言中，反射可以说是无处不在。 我们随时可以去新增、修改对象的属性，甚至可以重新定义对象中的方法，如我们日常使用的 apply 、 defineProperty 操作就属于典型的反射。 什么是元数据？元数据可以理解为：描述数据的数据。 比如现在有一个类，那么类里面的属性是描述这个类的数据。 描述属性的数据就可以理解为元数据，如属性的类型、方法属性的返回值等。 Reflect APIReflect 是 JavaScript 的一个 API，见 MDN。 它封装了一系列对对象底层静态操作方法，重新实现了类似 Object.defineProperty、Object.apply 等函数。 为什么需要Reflect理解了上面反射的概念后，有人不禁有些疑惑。运行时改变数据？这对JavaScript 来说不是很正常的事情吗？ 毕竟JavaScript 本身就是 runtime 的语言啊，像： 123const a = document.querySelectorAll(&#x27;a&#x27;)Array.prototype.slice.apply(a).forEach(item =&gt; &#123;...&#125;) 这不就是一个标准的反射吗？ 除了有点难记之外，好像也没啥不对的地方。 看一下 Reflect 的写法： 123const a = document.querySelectorAll(&#x27;a&#x27;)Reflect.apply(Array, Array, a).forEach(item =&gt; &#123;...&#125;) 嚯~，好像规整了很多。 Reflect 存在的意义就是规整反射API，将这些API 放到一个对象中统一管理。 现阶段Reflect 实现的API Reflect.apply() Reflect.construct() Reflect.defineProperty() Reflect.deleteProperty() Reflect.get() Reflect.getOwnPropertyDescriptor() Reflect.getPrototypeOf() Reflect.has() Reflect.isExtensible() Reflect.ownKeys() Reflect.preventExtensions() Reflect.set() Reflect.setPrototypeOf() 很眼熟吧… 很多都是原有方法的重新实现。 Reflect MetadataReflect API 对元数据的操作并不完善，因此 ES7 的规范额外提案了一些对 MetaData 操作。 不过目前浏览器兼容并不好， 我们可以通过 reflect-metadata 库来做 polyfill。 1npm i reflect-metadata -s reflect-metadata 并没有导出任何模块， 所以直接在程序入口引用即可。 1import &#x27;reflect-metadata&#x27;; 获取预设元信息Reflect Matedata 默认预设了几个 metadataKey,分别用于获取目标的类型、接受的参数类型、返回的结果类型。 design:type design:paramtypes design:returntype 12345678910111213141516171819202122232425function Prop(options: &#123; default: string &#125;) &#123; return (target: any, key: string) =&gt; &#123; console.log(Reflect.getMetadata(&quot;design:type&quot;, target, key).name); // String &#125;;&#125;function Method(target: any, key: string) &#123; const types = Reflect.getMetadata(&quot;design:paramtypes&quot;, target, key); const s = types.map((a: any) =&gt; a ? a.name : &quot;undefined&quot;).join(&quot;,&quot;); console.log(`$&#123;key&#125; param types: $&#123;s&#125;`); // onClick param types: String,Number const returnType = Reflect.getMetadata(&quot;design:returntype&quot;, target, key); // onClick return types: Promise console.log(`$&#123;key&#125; return types: $&#123;returnType.name&#125;`);&#125;class Test &#123; @Prop() public AProp!: string; @Method onClick(type: string, num: number): Promise&lt;number&gt; &#123; return new Promise&lt;number&gt;(resolve =&gt; 1) &#125;&#125; 快速添加元数据Reflect MetaData 是可以直接作为装饰器使用的，可以快捷的添加元数据。 12345678910@Reflect.metadata(&#x27;custom:name&#x27;, &#x27;a custom class&#x27;)class Vue &#123; @Reflect.metadata(&#x27;custom:name&#x27;, &#x27;a custom prop&#x27;) public AProp!: string;&#125;const vm = new Vue();console.log(Reflect.getMetadata(&#x27;custom:name&#x27;, Vue)) // a custom classconsole.log(Reflect.getMetadata(&#x27;custom:name&#x27;, vm, &#x27;AProp&#x27;)) // a custom prop 注意： 自属性上获取元数据的时候，第二个参数需要是一个实例，而非是原始 class 本身。 自定义元数据除了上面讲 Reflect Metadata 当做装饰器的用法外， Reflect 还暴露了一些控制 metadata 的方法. 如通过 defineMetadata 在自定义装饰器内部去操作 metadata 1Reflect.defineMetadata(&quot;defaultValue&quot;, &#x27;custom:name&#x27;, target, key); 业务用途元数据的操作略微有点偏底层，一般常用在框架级的底层设计中。 如深度Angular 的依赖注入、控制反转；Vue Class Template 的模型注册、属性收集等。 我们来尝试设计一个简单的 Vue @Props 装饰器，来达到设置 prop 默认值的效果： 12345678910111213141516171819202122232425262728293031// APP 启动器function bootstrap(vm: Vue) &#123; // 读取元信息 for (const prop in vm) &#123; // 读取元信息 const defaultValue = Reflect.getMetadata(&quot;defaultValue&quot;, vm, prop); // 为 props 添加原始值 Reflect.set(vm, prop, defaultValue); &#125; return vm;&#125;function Prop(options: &#123; default: string &#125;) &#123; return (target: any, key: string) =&gt; &#123; Reflect.defineMetadata(&quot;defaultValue&quot;, options.default, target, key); &#125;;&#125;class Vue &#123; @Prop(&#123; default: &quot;zhukejin&quot; &#125;) public AProp!: string;&#125;// 通过App 启动器启动程序const app = bootstrap(new Vue());console.log(app) // Vue &#123;AProp: &#x27;zhukejin&#x27;&#125; 喏 👆🏻。。 默认值已经添加进去了，同样的道理，我们可以通过 metadata 来标记元素，来达到收集、处理的目的。 常见问题 Reflect.getMetadata 获取到是 undefined 需要在 tsconfig.json 中开启配置 12&quot;experimentalDecorators&quot;: true,&quot;emitDecoratorMetadata&quot;: true,","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhukejin.com/categories/JavaScript/"}],"tags":[{"name":"Typescript","slug":"Typescript","permalink":"https://zhukejin.com/tags/Typescript/"}]},{"title":"Typescript 装饰器","slug":"typescript-decorator","date":"un33fin33","updated":"un00fin00","comments":true,"path":"2022/typescript-decorator/","permalink":"https://zhukejin.com/2022/typescript-decorator/","excerpt":"工欲善其事必先利其器 装饰者模式（Decorator Pattern）也称为装饰器模式，即在不改变对象自身的基础上，动态增加额外的职责，属于结构型模式的一种。 使用装饰者模式的优点是把对象核心职责和要装饰的功能分开 ，装饰者模式属于非侵入式的行为修改。 装饰器是一项实验性特性，在未来的版本中可能会发生改变。（来自官网） 虽然目前仅仅是实验性特性，但是装饰器肯定会有，最多变的也是用法，毕竟装饰器在 Java、Python 这种语言中的场景已经足够成熟了。","text":"工欲善其事必先利其器 装饰者模式（Decorator Pattern）也称为装饰器模式，即在不改变对象自身的基础上，动态增加额外的职责，属于结构型模式的一种。 使用装饰者模式的优点是把对象核心职责和要装饰的功能分开 ，装饰者模式属于非侵入式的行为修改。 装饰器是一项实验性特性，在未来的版本中可能会发生改变。（来自官网） 虽然目前仅仅是实验性特性，但是装饰器肯定会有，最多变的也是用法，毕竟装饰器在 Java、Python 这种语言中的场景已经足够成熟了。 开启配置在 Typescript 配置中需要开启装饰器支持 123456&#123; &quot;compilerOptions&quot;: &#123; &quot;target&quot;: &quot;ES5&quot;, &quot;experimentalDecorators&quot;: true &#125;&#125; 装饰器的种类 类装饰器 方法装饰器 属性装饰器 参数装饰器 访问器装饰器 装饰器的格式装饰器通常通过一个 闭包函数 来声明，返回的匿名函数将在编译时调用。 届时将传递一些参数，如构造器、调用上下文、被装饰者的键名、装饰器属性对象（仅方法装饰器存在）等。 123456789// 定义装饰器function expression() &#123; // 装饰器执行函数 return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) &#123;&#125;&#125;// 使用，注意这里用的是 expression 的返回值@expression()test () &#123;&#125; 使用闭包函数的好处是可以保留一些内存空间用于存储一些装饰器内部计算的逻辑，或者可以在调用装饰器的时候传递一些 Options 参数进去控制逻辑等。 同样也带来一些隐患，如函数上下文、原型链的复杂变化。 当然如果不需要的话，直接定义 function ，使用 @expression 调用即可。 类装饰器类装饰器在调用的时候，接收一个 contructor 参数， 为被装饰的 class 的构造器。 如何定义我们可以通过重载构造函数， 来为 class 添加一些自定义的值。 123456789101112131415161718192021222324252627// 定义装饰器function MixinClass&lt;T extends &#123;new(...args:any[]): Record&lt;any, any&gt;&#125;&gt;(constructor: T) &#123; // 重载构造函数 return class extends constructor &#123; aaa = &#x27;这是添加的属性&#x27; mixinFunc () &#123; console.log(&#x27;这是添加的方法&#x27;) &#125; &#125;&#125;@MixinClassclass Test &#123; f () &#123; console.log(this.aaa); this.mixinFunc() &#125;&#125;const t = new Test()t.f() // 执行结果这是添加的属性这是添加的方法 当然嚯~ 如果装饰器返回的 class 不继承 构造函数， 那等于是直接替换掉了被装饰的类（不过我想不到这种用法的业务场景 ~） 注意 在定义 Class 装饰器的时候，注意接收的参数，如： 1&lt;T extends &#123;new(...args:any[]): Record&lt;any, any&gt;&#125;&gt;(constructor: T) 如果参数不对， ts 会报签名类型错误: 1TS1238: Unable to resolve signature of class decorator when called as an expression. 业务场景 在声明 Vue 组件的时候，通过装饰器来定义一些属性，如声明 Props、Components，以达到简化写法的目的。 1234567@Options(&#123; props: &#123; type: String, &#125;,&#125;)export default class NextTaoButton extends Vue &#123;&#125; 方法装饰器方法装饰器目前研究下来，觉得是最有用的了~ 如何定义方法装饰器的定义和类装饰器基本相同，不同的是多接受一个参数，可以访问到方法的属性对象，如此来， 我们便可以通过拦截这个对象来进行一些附加、修改数据的操作。 12345678910111213141516171819202122232425export function ButtonProps(target: any, propertyKey: string, descriptor: PropertyDescriptor) &#123; let callCount = 0; // target.$set(&#x27;clickNumber&#x27;, target.clickNumber++) // 拿到真正的执行函数 const fn = descriptor.value; // 在函数调用的时候, 执行附加逻辑 function additionalFunc() &#123; console.log(callCount++); &#125; // 修改函数 descriptor.value = function(...args: any) &#123; additionalFunc(); // 调用原始业务逻辑 fn.apply(target, args); &#125;;&#125;@ButtonPropsonClick(params: string) &#123; console.log(&#x27;业务逻辑&#x27;)&#125; 如上述逻辑 定义 @ButtonProps， 并通过闭包存储一个 callCount。 并重新定义函数的执行块，将附加逻辑追加进去，注意调用 fn 的时候要保证this 指向正常。 执行结果如下： 1234560业务逻辑1业务逻辑2业务逻辑 业务场景一现有需求，我们需要对一些函数进行调用日志记录，就可以通过装饰器来实现。 12345678910111213141516171819202122232425262728293031323334353637383940// 定义装饰器export function Logger(logId?: string, handler?: (input: string, output: string) =&gt; string) &#123; const loggerInfo = Object.seal(&#123; logId: logId, input: &quot;&quot;, output: &quot;&quot;, custom: &quot;&quot; &#125;); // 模拟一个 日志服务 class LogService &#123; static publish(loggerInfo: &#123;logId?: string; input: string; output: string; custom: string&#125;) &#123; console.log(&quot;日志上报&quot;, new Date().getTime(), loggerInfo); &#125; &#125; return function( target: any, key: string, descriptor: TypedPropertyDescriptor&lt;any&gt; ) &#123; const oldValue = descriptor.value; // 重写执行方法 descriptor.value = function(...args: any) &#123; loggerInfo.input = `$&#123;key&#125;($&#123;args.join(&quot;,&quot;)&#125;)`; // 执行原方法 // 记录输出值 handler &amp;&amp; (loggerInfo.custom = handler(loggerInfo.input, loggerInfo.output) || &quot;&quot;); loggerInfo.output = oldValue.apply(this, args); // 被调用时，会自动发出一个事件 LogService.publish(loggerInfo); &#125;; return descriptor; &#125;;&#125;// 调用方@Logger(&#x27;onClick&#x27;)onClick(params: string) &#123; console.log(&#x27;业务逻辑&#x27;)&#125; 很简单嚯~ ，逻辑其实和上面定义点击次数是一样的，调用的时候只需要添加 @Logger ，就可以上报日志服务器。 业务场景二最最最常见的需求之一：为函数添加防抖或节流。 如果没有装饰器，我们可能会这么做： 12345import &#123; debounce &#125; from &#x27;lodash&#x27;onClick = debounce(() =&gt; &#123; console.log(&#x27;点击啦&#x27;)&#125;, 500) 或者通过create 创建 1234567891011import &#123; debounce &#125; from &#x27;lodash&#x27;onClick?: () =&gt; void_onClick () &#123; console.log(&#x27;点击啦&#x27;)&#125;created () &#123; this.onClick = debounce(this._onClick, 500)&#125; emmm~ 无论怎么写都不是很优雅。 ok 我们来用装饰器来实现： 定义 123456export function Debounce(wait = 200) &#123; return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) &#123; // 修改函数 descriptor.value = debounce(descriptor.value, wait) &#125;&#125; 使用 1234@Debounce()onClick() &#123; console.log(&quot;点击啦&quot;);&#125; 简单且优雅~ 装饰器叠加如果既需要防抖， 又需要Logger 呢？ 装饰器是可以叠加生效的 12345@Logger(&#x27;onclick&#x27;)@Debounce()onClick() &#123; console.log(&quot;点击啦&quot;);&#125; 这里涉及到一个装饰器的执行先后顺序问题 编译阶段代码从上往下执行，所以如果是定义注释器的时候使用了函数包裹，则会先自上而下执行闭包构造函数，如 Debounce 的母函数。 点击阶段是从下往上执行，计算模型为 Logger(Debounce(onClick))，上层函数会重新计算下层函数的返回函数。 属性装饰器 注意: 属性描述符不会做为参数传入属性装饰器，这与TypeScript是如何初始化属性装饰器的有关。 因为目前没有办法在定义一个原型对象的成员时描述一个实例属性，并且没办法监视或修改一个属性的初始化方法。返回值也会被忽略。因此，属性描述符只能用来监视类中是否声明了某个名字的属性。 – 来自官网 因为属性装饰器只能用在 class 中，且会在代码编译阶段调用，此时 class 尚未被实例化，所以是拿不到属性值的。 由于鄙人不信邪，挣扎着尝试了一下 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 定义装饰器function MathPower (target: any, propertyKey: string) &#123; target[propertyKey] = &#x27;zhukejin&#x27; // 无效 target[propertyKey].writable = false // 无效 let value = &#x27;zhukejin&#x27; const getter = () =&gt; &#123; return value &#125; const setter = (val: string) =&gt; &#123; console.log(333) value = val &#125; if (delete target[propertyKey]) &#123; // 无效 Object.defineProperty(target, propertyKey, &#123; get: getter, set: setter, configurable: true, enumerable: true &#125;) &#125;&#125;class Test &#123; @MathPower name = &#x27;&#x27; f () &#123; this.name = &#x27;libai&#x27; console.log(this.name); &#125;&#125;const t = new Test()t.name = &#x27;ttt&#x27;console.log(t.name) 属性的装饰器中，只能进行初始化参数的访问，并不能进行赋值、添加。 目前想不到什么业务场景可用… 不过官网提供了一个基于 reflect-metadata 的例子，获取可以用于真实业务场景， 比如通过元数据为一个参数添加备注、子信息等等 见 https://www.tslang.cn/docs/handbook/decorators.html#method-decorators 参数装饰器参数装饰器接受三个参数，前两个同上，第三个额外接收一个此参数在参数列表中的 index。 但是嚯，参数装饰器和属性装饰器类似：不可以修改。 所以可操作性就降低了很多，不过，我们可以通过监视参数传递配合方法装饰器，来执行一些额外的方法，比如必填校验？ 123456789101112131415161718192021222324252627282930313233343536// 定义装饰器function Required() &#123; // 收集 Required index const requiredIndex: &#123; index: number; propertyKey: string &#125;[] = []; return function(action?: &quot;collect&quot; | &quot;validate&quot;) &#123; if (action === &quot;validate&quot;) &#123; // 返回新地校验函数 return function(target: any, propertyKey: string, descriptor: PropertyDescriptor) &#123; // 修改函数 const fn = descriptor.value; descriptor.value = function(...args: any) &#123; // 调用时候校验 for (const index in requiredIndex) &#123; if (!args[index].index) &#123; // 抛错 throw Error(`请传入函数 $&#123;requiredIndex[index].propertyKey&#125; 的 第 $&#123;requiredIndex[index].index&#125; 个必填参数`) &#125; &#125; fn.apply(target, args); &#125;; &#125;; &#125; else &#123; // 正常返回必填项收集装饰器 return function(target: any, propertyKey: string, index: number) &#123; // 收集 requiredIndex.push(&#123; index, propertyKey &#125;); &#125; &#125; &#125;;&#125; 调用： 123456789101112131415const R = Required();class Test &#123; @R(&#x27;validate&#x27;) f(@R() name: string) &#123; // console.log(name); &#125;&#125;const t = new Test();t.f(11);// 执行结果，抛错：// Uncaught Error: 请传入函数 f 的 第 0 个必填参数 这里的定义逻辑是通过闭包，存储一个必填收集器，然后返回一个方法，返回的方法再根据参数分化出两个装饰器。（其实也算工厂模式嚯） 这样的嵌套的目的是保证两个装饰器既能区分用途，又能保持同一个执行 scope（对没错，就真的只是为了在闭包中存储必填收集器…） 当然这只是个Demo，讲道理 emmm， 实际业务场景是有，但~不多！关键还是得靠方法装饰器。 但既然已经用方法装饰器了，压根就不需要整这么复杂~ 上面这个例子， 如果借助 Reflect matedata 来做的话，会简单很多， 因为不需要额外的存储空间。直接将信息放到元数据中即可。 访问器装饰器访问器装饰器和方法装饰器有点类似，可以通过第三个参数来改变get、set。 但是需要注意 TypeScript不允许同时装饰一个成员的get和set访问器。取而代之的是，一个成员的所有装饰的必须应用在文档顺序的第一个访问器上。这是因为，在装饰器应用于一个属性描述符时，它联合了get和set访问器，而不是分开声明的。 – 来自官网 12345678910111213141516function WhenGet(target: any, key: string, descriptor: PropertyDescriptor) &#123; descriptor.get = function () &#123; return &#x27;ccc&#x27; &#125;&#125;class Test &#123; @WhenGet get name() &#123; return &#x27;zhukejin&#x27; &#125;&#125;const t = new Test();console.log(t.name) // ccc","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhukejin.com/categories/JavaScript/"}],"tags":[{"name":"Typescript","slug":"Typescript","permalink":"https://zhukejin.com/tags/Typescript/"}]},{"title":"Less 的一些高级用法","slug":"advanced-less","date":"un55fin55","updated":"un00fin00","comments":true,"path":"2022/advanced-less/","permalink":"https://zhukejin.com/2022/advanced-less/","excerpt":"最近发现很多同学在使用 Less 的时候， 仅是为了使用 Less 的 变量、嵌套 以及 module 功能。 虽然 Less 相对于 Sass 来说，移除了很多功能，比如 @if @else @while @for @function等，但是并非是Less 不行，Less 的宗旨是 “Do Less Get More”。 我们可以在简洁的API 支撑下，做到更多的事情。 曾经我是个 Scss 党，现在已经全面转 Less 了。","text":"最近发现很多同学在使用 Less 的时候， 仅是为了使用 Less 的 变量、嵌套 以及 module 功能。 虽然 Less 相对于 Sass 来说，移除了很多功能，比如 @if @else @while @for @function等，但是并非是Less 不行，Less 的宗旨是 “Do Less Get More”。 我们可以在简洁的API 支撑下，做到更多的事情。 曾经我是个 Scss 党，现在已经全面转 Less 了。 导入导出提到导入导出，大家可能都在想，一个 @import 就搞定的事情，这也拿来讲？ 在Less 初期，确实都是 @import 导入文件一把梭，但是这同样也会带来代码冗余的问题，比如生成重复代码等。 Less v1.4 版本后，编译器新增了 import 参数的支持，如 静默导入在导入的文件前，添加下划线前缀即可静默引入，即不生成实体代码，仅作为变量使用。 12// color filename：color.less@import &#x27;_color&#x27; refrence1@import (refrence) &#x27;color&#x27; refrence 可以配合 extend&#x2F;mixins 关键字使用，如 123456789101112// color.less.a &#123; ...&#125;.b &#123; ...&#125;// gap.less@import (refrence) &#x27;color&#x27;;.a:extend(.a all) 这样就只继承 color.less 的 .a ，同时在编译后的文件中，不会生成 .b 的 less 代码。 inline如果某些css 不想被编译，且还需要引入的话，可以使用这个参数 1@import (inline) &#x27;color.css&#x27; 这样在编译项目的时候， color.css 不会经由 Less 编译器编译，这个设计的目的是防止某些编译器不支持的高级css 属性导致编译报错。 其他的参数还有： once(默认) multiple less css 有兴趣的可以自行查阅文档。 变量普通的变量定义和引用，每种语言都一样，大家神会即可，说点 Less 不一样的。 属性变量将变量作为 key 来使用，使用 @{} 来插值 123456789101112@color: red;.@&#123;color&#125; &#123; color: @color; font-size: 100px;&#125;// 编译结果.red &#123; color: red; font-size: 100px;&#125; 变量拼接变量作为 value 使用的时候，需要用~和引号来进行插值计算，如果不加 ~ ，则会生成字符串类型的值。 123456789101112131415.a (@p, @u) &#123; font-size: ~&quot;@&#123;p&#125;px&quot;; background: url(&quot;@&#123;u&#125;&quot;);&#125;.b &#123; .a(10, &#x27;https://xxx.com/a.jpg&#x27;);&#125;// 编译结果.b &#123; font-size: 10px; background: url(&quot;https://xxx.com/a.jpg&quot;);&#125; 路径变量在导入文件时，同样可以使用变量，来达到按需导入的效果。 123456789101112131415161718192021// 两个主题文件// theme/dark.less@color: red;// theme/light.less@color: blue;// file@theme: &quot;dark&quot;;@import &quot;theme/@&#123;theme&#125;.less&quot;;.a &#123; color: @color;&#125;// 编译结果.a &#123; color: red;&#125; 变量引用同属性变量，既然变量可以作为 style 的属性，那也能作为变量的引用来用，从而就可以实现 PHP 中 $$$$a 这样的套娃用法 看我套娃~ 1234567891011@a: &#x27;i am origin a&#x27;;@b: &#x27;a&#x27;;a &#123; content: @@b;&#125;// 编译结果a &#123; content: &#x27;i am origin a&#x27;;&#125; 变量提升同 JavaScript，Less 中的变量， 也是会提升的 12345a &#123; color: @a;&#125;@a: red; 混入基础用法混入 (Mixins) 可以说是 Sass 和 Less 中一个比较常见的功能，在 Less 中基础用法比较简单: 123456789101112.a &#123; color: red;&#125;.b &#123; .a;&#125;// 编译结果.b &#123; color: red;&#125; less: 人家都说我清纯不做作， 不像外面那个 sass。 Sass 中将这个功能细分为 @mixin 、@include、@extend、@content，有兴趣的可以去研究一下。 毕竟大多数项目是不需要优化到如此地步的，即便需要优化， 也可以通过嵌套规则来优化。 函数混入Mixins 可以作为函数使用，从而实现类似 @functions 的功能 12345678910111213.a(@color: red) &#123; color: @color;&#125;.b &#123; .a(blue); &#125;// 编译结果.b &#123; color: #0000ff;&#125; 如果作为函数使用，则自身不会被编译到css 文件中。 高级函数混入Less 实现了一些高级语言才有的函数特性，如 JavaScript 中的 arguments、解构参数； Python 中的 **kwargs； 123456789101112131415161718.a (...) &#123; border: @arguments;&#125;.a1 (@px: 1px, @reset...) &#123; border: @px @reset;&#125;.b &#123; .a(1px, solid, red); .a1(2px, solid, red);&#125;// 编译结果.b &#123; border: 1px solid #ff0000; border: 2px solid #ff0000;&#125; @arguments 可接收到所有的参数集 @rest 可接收到 … 定义的参数集 高级函数重载这里其实和强类型语言中的重载不太一样，不过为了方便理解，可以认为就是模拟重载。 123456789101112131415161718.a (@p1, @p2) &#123; color: red;&#125;.a (@p1) &#123; color: blue;&#125;.b &#123; .a(p1); .a(p1, p2);&#125;// 编译结果.b &#123; color: blue; color: red;&#125; 可以看到如同函数重载一般，当签名不同的时候，返回不同的结果。 混入作用域默认的 Mixins 是可以继承调用方上下文的，即可以使用 &amp; 来继承父级，针对比较复杂的场景，Less 提供了 #(命名空间) 加上 &gt; 来控制作用域。 1234567891011121314151617#first &#123; .a() &#123; color: red; &#125;&#125; #sec &#123; .a() &#123; color: green; &#125;&#125; .b &#123; #first &gt; .a; #sec &gt; .a; &#125; 通过上面的例子可以看到， 我们可以通过命名空间 + &gt; 来控制使用哪个同名混入。 关于 # 命名空间，后面有讲。 函数返回值Less 并没有 Sass 中的 @return 关键字，但是因为作用域的共享，可以通过变量来实现 @return 的用法。 12345678910111213.a() &#123; @color: red; &#125;.b &#123; .a(); color: @color;&#125;// 编译结果.b &#123; color: #ff0000;&#125; 可以看到，@color 变量在经过 .b 的调用后，已经可以在 .b 作用域内使用。 Mixin 条件虽然 Less 没有提供 @if @else 等流程控制符，但是提供了 when 关键字， 配合 mixin 重载，灵活使用可以实现类似流程控制的效果。 123456789101112131415161718192021222324252627282930.a (@p) when (@p &lt; 10) &#123; border: ~&#x27;@&#123;p&#125;px&#x27; solid red;&#125;// 如果是or，则用 逗号分割即可.a (@p) when (@p &gt; 10) and (@p &lt; 15) &#123; border: ~&#x27;@&#123;p&#125;px&#x27; solid blue;&#125;.a (@p) when not (@p &lt; 15) &#123; border: ~&#x27;@&#123;p&#125;px&#x27; solid green;&#125;.a (@p) when (default()) &#123; // 这里是类似 else 的语法 // 当然在这一串控制中不会生效， 因为上面三个已经可以涵盖所有情况&#125;.b &#123; .a(9); .a(11); .a(20);&#125;// 编译结果.b &#123; border: 9px solid #ff0000; border: 11px solid #0000ff; border: 20px solid #008000;&#125; Mixin 合并(v1.7.0 支持)Less 支持 Mixin 的合并选项 12345678910111213141516.a &#123; box-shadow+: inset 0 0 10px red; border+_: 1px;&#125;.b &#123; .a(); box-shadow+: 0 0 10px green; border+_: solid red;&#125;// 编译结果.b &#123; box-shadow+: inset 0 0 10px red, 0 0 10px green; border: 1px solid red;&#125; 为避免任何非有意的添加，merge需要在每个待加入的声明中显示的设置一个+或者+_标记。 (引自官方文档：https://www.html.cn/doc/less/features/#merge-feature-comma-) 循环递归循环Less 可以通过 when 和 递归 mixin 来实现 Sass 中 @while 循环的效果 123456789101112131415161718192021.a (@i: 1) when (@i &lt; 11)&#123; .mr-@&#123;i&#125; &#123; margin-right: ~&#x27;@&#123;i&#125;px&#x27;; &#125; .a (@i + 1);&#125;.a()// 编译结果.mr-1 &#123; margin-right: 1px;&#125;.mr-2 &#123; margin-right: 2px;&#125;....mr-10 &#123; margin-right: 10px;&#125; 列表循环Less 中通过变量可以定义一个列表，如： 1@strings: left, right, top, bottom; 此时可以通过 each 函数来循环这个列表（each 方法文档中没有，我也忘记咋知道这个方法的了~ - -~） 12345678910111213141516171819each(@strings, .(@type) &#123; .@&#123;type&#125; &#123; margin-@&#123;type&#125;: 10px; &#125;&#125;)// 编译结果.left &#123; margin-left: 10px;&#125;.right &#123; margin-right: 10px;&#125;.top &#123; margin-top: 10px;&#125;.bottom &#123; margin-bottom: 10px;&#125; 嚯！到这里终于来点有用的场景了，这个写法很 JavaScript 。 函数上面讲过我们用 Mixin 去模拟自定义函数，Less 自身也提供了很多常见的操作函数。 颜色函数通过这些函数可以进行色彩计算、转换。 hsl() &#x2F; hsla() 通过色相 (hue)，饱和度 (saturation)，亮度 (lightness)，alpha 四种值 (HSLA) 创建不透明的颜色对象。 Hsv() &#x2F; hsva() 通过色相 (hue)，饱和度 (saturation)，色调 (value)，以及 alpha 四种值 (HSVA) 创建透明的颜色对象。 hue saturation lightness red green blue alpha lighten darken fadein fadeout mix 混色，将两个颜色混成一个。 等等 类型函数在混入的时候，可以通过类型函数来判断输出结果 isnumber isstring iscolor isurl Isunit 是否为单位(px&#x2F;em&#x2F;rem) ispercentage ispixel isem 等等 数学函数写动画效果、图形计算的时候非常有用，不列举了。常见的JavaScript Math 对象方法都在里面。 工具函数某些场景贼好用 data-uri 将一个资源转为 base64 格式 data-uri(‘..&#x2F;data&#x2F;image.jpg’); 输出：url(‘data:image&#x2F;jpeg;base64,bm90IGFjdHVhbGx5IGEganBlZyBmaWxlCg&#x3D;&#x3D;’); util 添加或移除一个单位，在配合变量使用的时候效果极佳 Util(5, px) 输出 5px 等等 JavaScript in LessLess 支持一个很神奇的特性，可能跟底层是 JavaScript 实现有关。 它支持我们在 Less 中编写 JavaScript，仅限 ES5，不过即便如此， 还是可以通过这个特性来大大扩展 Less 的灵活性。 从这刻起，Less 就是一门完整的编程语言了。 ant design 中就是使用这种方法来计算 Button 色阶 开启编译支持javascript in less 需要 less loader 额外开启，默认是关闭的~ 12345678910// webpack// 这里是通过 vue 的 config 覆写语法来做的，道理都一样，目的就是开启 lessLoader 中 lessOptions 里的 JavaScriptEnabledconfig.module.rule(&#x27;less&#x27;).oneOf(module).use(&#x27;less-loader&#x27;).loader(&#x27;less-loader&#x27;) .tap(options =&gt; &#123; options.lessOptions = &#123; javascriptEnabled : true &#125; return options&#125;) JavaScript 编写1234567891011.funtionFactory &#123; // 因为不支持 es6，所以只能写 function @functions: ~`(function () &#123; var color = &#x27;red&#x27; // 将供less 使用的函数挂在原型链上，我猜less loader 内部会 new 外层这个匿名函数~ this.getColor = function () &#123; return color &#125; &#125;&#125; Less 中调用 JavaScript 方法1234567891011// 先调用工厂函数，生成作用域内的方法.funtionFactory();.a &#123; color: ~`getColor()`;&#125;// 编译结果.a &#123; color: red;&#125; 注意： less 中调用 JavaScript 方法的时候，是可以传递参数的。 所以我们平常也可以把 Less 中一些复杂的计算转移到 JavaScript 中去。 业务场景需求在日常开发中，搭建底层样式库的时候，为了方便 UI 绘制，我决定要创建一些辅助间距class，类似 Material UI 中的 pl、ml。 但是 Material 显然是通过 React 来计算的，那我们使用 Less 要怎么做呢？ 结合一下上面的各种用法，很轻松就得出了答案：变量、循环、JavaScript。 来看一下如何实现~ 实现：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// 定义使用到的边距// 如 pb10: padding-bottom: 10// 定义变量转换函数.functionFactory() &#123; @functions: ~`(function () &#123; var map = &#123; m: &#x27;margin&#x27;, p: &#x27;padding&#x27;, t: &#x27;-top&#x27;, r: &#x27;-right&#x27;, b: &#x27;-bottom&#x27;, l: &#x27;-left&#x27;, &#125; this.getFullAttr = function (str) &#123; if (str.length === 1) &#123; return map[str] &#125; var newStr = str.replace(/([a-z])([a-z])/g, function ($0, $1, $2) &#123; return map[$1] + map[$2] &#125;) return newStr &#125; &#125;)()`&#125;.functionFactory();// 定义循环构造体.eachFactory(@list) &#123; each(@list, .(@value) &#123; each(@types, .(@type) &#123; @fullType: ~`getFullAttr(&quot;@&#123;type&#125;&quot;)`; .@&#123;type&#125;@&#123;value&#125; &#123; @&#123;fullType&#125;: ~&quot;@&#123;value&#125;px !important&quot;; &#125; &#125;) &#125;)&#125;// 定义的边距类型@types: pt, pr, pb, pl, mt, mr, mb, ml, p, m;// 10 以下者皆定义,@baseGapList: range(0, 10, 1);// 除此之外，余则加之@expandGapList: 12, 16, 20, 24, 30, 32, 38, 40, 46, 50, 80, 100;.eachFactory(@baseGapList);.eachFactory(@expandGapList); 这段代码编译后，就会生成四个边的边距 style，如直接在项目中使用 pl8、pr16、mb24 即可。","categories":[{"name":"CSS","slug":"CSS","permalink":"https://zhukejin.com/categories/CSS/"}],"tags":[{"name":"LESS","slug":"LESS","permalink":"https://zhukejin.com/tags/LESS/"}]},{"title":"如何利用 KODI 播放阿里云盘的电影","slug":"kodi-webdav-alipan","date":"un55fin55","updated":"un00fin00","comments":true,"path":"2022/kodi-webdav-alipan/","permalink":"https://zhukejin.com/2022/kodi-webdav-alipan/","excerpt":"真香","text":"真香 需求最近发掘了好多阿里云盘的资源，也可以在阿里云盘Tv 版直接在线观看，但是存在一些弊端，如： 无法切换音轨 在线字幕服务很烂 非会员不能播放4K（即使能播放也很卡） 解决方案一有需求就有解决方案，我决定使用 KODI 去播放阿里云盘的视频，以解决这个问题，需要使用到东西 KODI 软件TV版 docker Mac 版（我局域网服务是用mac 搭建的，当然windows 也可以，有NAS 更好） docker 官网下载，然后注册、安装、启动。 解决方案二2022年08月09日更新 在实际使用中发现一个问题，mac 的docker 占用内存过大，原因是 docker 本身为 unix 软件，在mac 上的实现是通过unix 虚拟机+ docker 本体来做的，基本后台挂了docer，3G-4G的内存就没了，怕了怕了。 KODI 软件TV版（这个当然不变了） 命令行注册 WebDav 服务 通过命令行注册 WebDav 服务，实测内存占用40M 左右，具体方案见下方本地服务。 获取阿里云盘的token手动获取登陆阿里云盘 Web 版本，在 localStorage 中找到 token 字段，在token 中找到 refresh token，是一串hash， 复制出来 命令行获取1aliyundrive-webdav qr login 本地服务Docker然后打开终端，输入下面代码，下载webdav镜像，注意里面的 ALIYUNDRIVE_REFRESH_TOKEN 换成刚刚拿到的 refresh token 12345docker run -d --name=webdav-aliyundriver --restart=always -p 8080:8080 -v /etc/localtime:/etc/localtime -v /etc/aliyun-driver/:/etc/aliyun-driver/ -e TZ=&quot;Asia/Shanghai&quot; -e ALIYUNDRIVE_REFRESH_TOKEN=&quot;your refreshToken&quot; -e ALIYUNDRIVE_AUTH_PASSWORD=&quot;admin&quot; -e JAVA_OPTS=&quot;-Xmx1g&quot; yuanhaishan/webdav-aliyundriver:v2.4.0# /etc/aliyun-driver/ 挂载卷自动维护了最新的refreshToken，建议挂载# ALIYUNDRIVE_AUTH_PASSWORD 是admin账户的密码，建议修改# JAVA_OPTS 可修改最大内存占用，比如 -e JAVA_OPTS=&quot;-Xmx512m&quot; 表示最大内存限制为512m 纯命令行见 Github 安装 aliyundrive-webdav 命令行后执行即可启动 1aliyundrive-webdav -r [token] -p [port] 本地挂载推荐使用 CloudMounter，下载安装打开后, 选择WebDAV 点击挂载，这个时候云盘已经挂载在本地了 KODI 配置远程服务进入视频菜单，点击“进入文件区” ，添加视频-&gt;浏览 -&gt; 添加网络位置，选择 webdav （http），然后输入 刚刚电脑的IP地址、端口 8080，账号密码 admin，确定后显示出远程目录，连接成功。","categories":[{"name":"Other","slug":"Other","permalink":"https://zhukejin.com/categories/Other/"}],"tags":[{"name":"Tool","slug":"Tool","permalink":"https://zhukejin.com/tags/Tool/"}]},{"title":"关于 WebStorm 2021.3 的破解方法","slug":"activition-webstorm-2021-3","date":"un55fin55","updated":"un00fin00","comments":true,"path":"2022/activition-webstorm-2021-3/","permalink":"https://zhukejin.com/2022/activition-webstorm-2021-3/","excerpt":"在 WebStorm 2021.3 版本中，传统的重置试用、fineagent.jar 方式破解都已失效，本文以 MacOS 为例。 仅用于学习用途哟~","text":"在 WebStorm 2021.3 版本中，传统的重置试用、fineagent.jar 方式破解都已失效，本文以 MacOS 为例。 仅用于学习用途哟~ 最新破解方式1. 卸载旧版本完全卸载旧版本 IDEA，切记移除 host 相关内容 2. 下载 agent下载地址 将云盘中所有内容下载到本地，存入一个文件夹中 切记不要改任何东西 3. 执行激活脚本1sh /Users/angular/Documents/tnt/ja-netfilter-all/scripts/install.sh 其中 /Users/angular/Documents/tnt/ja-netfilter-all 为我存储的 破解文件夹路径. 当看到终端显示 Down 后即代表执行完毕。 运行脚本安装破解补丁完成后，一定要重启 IDEA windows 用户执行 install-current-user.vbs 脚本 4. 输入注册码打开WebStorm，选择 Activation code, 输入下面激活码： 1YJQB4P18ZS-eyJsaWNlbnNlSWQiOiJZSlFCNFAxOFpTIiwibGljZW5zZWVOYW1lIjoidHJlbmRzIHJhYmJpcyIsImFzc2lnbmVlTmFtZSI6IiIsImFzc2lnbmVlRW1haWwiOiIiLCJsaWNlbnNlUmVzdHJpY3Rpb24iOiIiLCJjaGVja0NvbmN1cnJlbnRVc2UiOmZhbHNlLCJwcm9kdWN0cyI6W3siY29kZSI6IldTIiwiZmFsbGJhY2tEYXRlIjoiMjAyMy0wMi0wOCIsInBhaWRVcFRvIjoiMjAyMy0wMi0wOCIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiUFdTIiwiZmFsbGJhY2tEYXRlIjoiMjAyMy0wMi0wOCIsInBhaWRVcFRvIjoiMjAyMy0wMi0wOCIsImV4dGVuZGVkIjp0cnVlfSx7ImNvZGUiOiJQU0kiLCJmYWxsYmFja0RhdGUiOiIyMDIzLTAyLTA4IiwicGFpZFVwVG8iOiIyMDIzLTAyLTA4IiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IlBDV01QIiwiZmFsbGJhY2tEYXRlIjoiMjAyMy0wMi0wOCIsInBhaWRVcFRvIjoiMjAyMy0wMi0wOCIsImV4dGVuZGVkIjp0cnVlfV0sIm1ldGFkYXRhIjoiMDEyMDIyMDIwOFBTQU4wMDAwMDUiLCJoYXNoIjoiVFJJQUw6MTA5NjI1MTU0OCIsImdyYWNlUGVyaW9kRGF5cyI6NywiYXV0b1Byb2xvbmdhdGVkIjpmYWxzZSwiaXNBdXRvUHJvbG9uZ2F0ZWQiOmZhbHNlfQ==-aox1Rz0dSIQBtpXHUuEVWlmAa7Nc2tWGZ86EFQsyg2P3dijy3dB0H/Ky4Vu0kjuASRue+4mLsPVrpalNeQ4+K1A8shurIuFOiLKKlGmHYIwHAV9ggDiE5/gtDny7JwvidkPt/KA/o00Q9w/3fIxBhMWlUxcNJTU1IacAyFEGFk2F0hsC6Hi8PKc+yowJfZR+fpZaVtZ3nOpR4hAs2+Csnurx6ud8MW+jFaN1NntIPyku+CZHajBr1s9S1PMh7UJvgaxfXSAV1mH1Y6QT//lJ+Yhp0wjbyXalVd4kWpomMh+eQr/bzE5WgpuTOVOBKInIGTW3O4U2uaHks6nOMEv+Bw==-MIIETDCCAjSgAwIBAgIBDTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTIwMTAxOTA5MDU1M1oXDTIyMTAyMTA5MDU1M1owHzEdMBsGA1UEAwwUcHJvZDJ5LWZyb20tMjAyMDEwMTkwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCUlaUFc1wf+CfY9wzFWEL2euKQ5nswqb57V8QZG7d7RoR6rwYUIXseTOAFq210oMEe++LCjzKDuqwDfsyhgDNTgZBPAaC4vUU2oy+XR+Fq8nBixWIsH668HeOnRK6RRhsr0rJzRB95aZ3EAPzBuQ2qPaNGm17pAX0Rd6MPRgjp75IWwI9eA6aMEdPQEVN7uyOtM5zSsjoj79Lbu1fjShOnQZuJcsV8tqnayeFkNzv2LTOlofU/Tbx502Ro073gGjoeRzNvrynAP03pL486P3KCAyiNPhDs2z8/COMrxRlZW5mfzo0xsK0dQGNH3UoG/9RVwHG4eS8LFpMTR9oetHZBAgMBAAGjgZkwgZYwCQYDVR0TBAIwADAdBgNVHQ4EFgQUJNoRIpb1hUHAk0foMSNM9MCEAv8wSAYDVR0jBEEwP4AUo562SGdCEjZBvW3gubSgUouX8bOhHKQaMBgxFjAUBgNVBAMMDUpldFByb2ZpbGUgQ0GCCQDSbLGDsoN54TATBgNVHSUEDDAKBggrBgEFBQcDATALBgNVHQ8EBAMCBaAwDQYJKoZIhvcNAQELBQADggIBAB2J1ysRudbkqmkUFK8xqhiZaYPd30TlmCmSAaGJ0eBpvkVeqA2jGYhAQRqFiAlFC63JKvWvRZO1iRuWCEfUMkdqQ9VQPXziE/BlsOIgrL6RlJfuFcEZ8TK3syIfIGQZNCxYhLLUuet2HE6LJYPQ5c0jH4kDooRpcVZ4rBxNwddpctUO2te9UU5/FjhioZQsPvd92qOTsV+8Cyl2fvNhNKD1Uu9ff5AkVIQn4JU23ozdB/R5oUlebwaTE6WZNBs+TA/qPj+5/we9NH71WRB0hqUoLI2AKKyiPw++FtN4Su1vsdDlrAzDj9ILjpjJKA1ImuVcG329/WTYIKysZ1CWK3zATg9BeCUPAV1pQy8ToXOq+RSYen6winZ2OO93eyHv2Iw5kbn1dqfBw1BuTE29V2FJKicJSu8iEOpfoafwJISXmz1wnnWL3V/0NxTulfWsXugOoLfv0ZIBP1xH9kmf22jjQ2JiHhQZP7ZDsreRrOeIQ/c4yR8IQvMLfC0WKQqrHu5ZzXTH4NO3CwGWSlTY74kE91zXB5mwWAx1jig+UXYc2w4RkVhy0//lOmVya/PEepuuTTI4+UJwC7qbVlh5zfhj8oTNUXgN0AOc+Q0/WFPl1aw5VV/VrO8FCoB15lFVlpKaQ1Yh+DVU8ke+rt9Th0BCHXe0uZOEmH0nOnH/0onD 点击激活即可 附本方式也适用于 Jetbrains 其他 IDEA，但 激活码不同，详见下述： JAVA IDEA1W438N4X12J-eyJsaWNlbnNlSWQiOiJXNDM4TjRYMTJKIiwibGljZW5zZWVOYW1lIjoidHJlbmRzIHJhYmJpcyIsImFzc2lnbmVlTmFtZSI6IiIsImFzc2lnbmVlRW1haWwiOiIiLCJsaWNlbnNlUmVzdHJpY3Rpb24iOiIiLCJjaGVja0NvbmN1cnJlbnRVc2UiOmZhbHNlLCJwcm9kdWN0cyI6W3siY29kZSI6IklJIiwiZmFsbGJhY2tEYXRlIjoiMjAyMy0wMi0wOCIsInBhaWRVcFRvIjoiMjAyMy0wMi0wOCIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiUERCIiwiZmFsbGJhY2tEYXRlIjoiMjAyMy0wMi0wOCIsInBhaWRVcFRvIjoiMjAyMy0wMi0wOCIsImV4dGVuZGVkIjp0cnVlfSx7ImNvZGUiOiJQV1MiLCJmYWxsYmFja0RhdGUiOiIyMDIzLTAyLTA4IiwicGFpZFVwVG8iOiIyMDIzLTAyLTA4IiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IlBHTyIsImZhbGxiYWNrRGF0ZSI6IjIwMjMtMDItMDgiLCJwYWlkVXBUbyI6IjIwMjMtMDItMDgiLCJleHRlbmRlZCI6dHJ1ZX0seyJjb2RlIjoiUFBTIiwiZmFsbGJhY2tEYXRlIjoiMjAyMy0wMi0wOCIsInBhaWRVcFRvIjoiMjAyMy0wMi0wOCIsImV4dGVuZGVkIjp0cnVlfSx7ImNvZGUiOiJQUEMiLCJmYWxsYmFja0RhdGUiOiIyMDIzLTAyLTA4IiwicGFpZFVwVG8iOiIyMDIzLTAyLTA4IiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IlBSQiIsImZhbGxiYWNrRGF0ZSI6IjIwMjMtMDItMDgiLCJwYWlkVXBUbyI6IjIwMjMtMDItMDgiLCJleHRlbmRlZCI6dHJ1ZX0seyJjb2RlIjoiUFNXIiwiZmFsbGJhY2tEYXRlIjoiMjAyMy0wMi0wOCIsInBhaWRVcFRvIjoiMjAyMy0wMi0wOCIsImV4dGVuZGVkIjp0cnVlfSx7ImNvZGUiOiJQU0kiLCJmYWxsYmFja0RhdGUiOiIyMDIzLTAyLTA4IiwicGFpZFVwVG8iOiIyMDIzLTAyLTA4IiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IlBDV01QIiwiZmFsbGJhY2tEYXRlIjoiMjAyMy0wMi0wOCIsInBhaWRVcFRvIjoiMjAyMy0wMi0wOCIsImV4dGVuZGVkIjp0cnVlfV0sIm1ldGFkYXRhIjoiMDEyMDIyMDIwOFBTQU4wMDAwMDUiLCJoYXNoIjoiVFJJQUw6LTIwMDMxNDk5MzciLCJncmFjZVBlcmlvZERheXMiOjcsImF1dG9Qcm9sb25nYXRlZCI6ZmFsc2UsImlzQXV0b1Byb2xvbmdhdGVkIjpmYWxzZX0=-U0uteIUdI7Pn3l6b42jdvpWmT4iDDXJcC69WIw3EB4sX47Qt98McKvbzUHKsAftFyMRG7HhyG5aFCnQYqVKgOAgYuOZ+vhT4yGHOMHpWtJ/cJnKHmki+pv7jhEc7gfyyk0Gv+5dzdKUGlinX357XGrfe4WJjtRXb6txvgChdlG8wqqi8t9VO7+n5N8XxCStgAmB6eOGVY00ZzXvdP96RRU4YdbD4NM3Hu49ZOC9eR7NxZADSmkhg3F6NPBMKPyQ/QKhFEXaqcexoYcQdwUkLjqUxsvs8zglHp0toM5jcccfqJ2EVbRSsrk5j7qL/h1QvSQJepRzrn8qra9Ne62eaUw==-MIIETDCCAjSgAwIBAgIBDTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTIwMTAxOTA5MDU1M1oXDTIyMTAyMTA5MDU1M1owHzEdMBsGA1UEAwwUcHJvZDJ5LWZyb20tMjAyMDEwMTkwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCUlaUFc1wf+CfY9wzFWEL2euKQ5nswqb57V8QZG7d7RoR6rwYUIXseTOAFq210oMEe++LCjzKDuqwDfsyhgDNTgZBPAaC4vUU2oy+XR+Fq8nBixWIsH668HeOnRK6RRhsr0rJzRB95aZ3EAPzBuQ2qPaNGm17pAX0Rd6MPRgjp75IWwI9eA6aMEdPQEVN7uyOtM5zSsjoj79Lbu1fjShOnQZuJcsV8tqnayeFkNzv2LTOlofU/Tbx502Ro073gGjoeRzNvrynAP03pL486P3KCAyiNPhDs2z8/COMrxRlZW5mfzo0xsK0dQGNH3UoG/9RVwHG4eS8LFpMTR9oetHZBAgMBAAGjgZkwgZYwCQYDVR0TBAIwADAdBgNVHQ4EFgQUJNoRIpb1hUHAk0foMSNM9MCEAv8wSAYDVR0jBEEwP4AUo562SGdCEjZBvW3gubSgUouX8bOhHKQaMBgxFjAUBgNVBAMMDUpldFByb2ZpbGUgQ0GCCQDSbLGDsoN54TATBgNVHSUEDDAKBggrBgEFBQcDATALBgNVHQ8EBAMCBaAwDQYJKoZIhvcNAQELBQADggIBAB2J1ysRudbkqmkUFK8xqhiZaYPd30TlmCmSAaGJ0eBpvkVeqA2jGYhAQRqFiAlFC63JKvWvRZO1iRuWCEfUMkdqQ9VQPXziE/BlsOIgrL6RlJfuFcEZ8TK3syIfIGQZNCxYhLLUuet2HE6LJYPQ5c0jH4kDooRpcVZ4rBxNwddpctUO2te9UU5/FjhioZQsPvd92qOTsV+8Cyl2fvNhNKD1Uu9ff5AkVIQn4JU23ozdB/R5oUlebwaTE6WZNBs+TA/qPj+5/we9NH71WRB0hqUoLI2AKKyiPw++FtN4Su1vsdDlrAzDj9ILjpjJKA1ImuVcG329/WTYIKysZ1CWK3zATg9BeCUPAV1pQy8ToXOq+RSYen6winZ2OO93eyHv2Iw5kbn1dqfBw1BuTE29V2FJKicJSu8iEOpfoafwJISXmz1wnnWL3V/0NxTulfWsXugOoLfv0ZIBP1xH9kmf22jjQ2JiHhQZP7ZDsreRrOeIQ/c4yR8IQvMLfC0WKQqrHu5ZzXTH4NO3CwGWSlTY74kE91zXB5mwWAx1jig+UXYc2w4RkVhy0//lOmVya/PEepuuTTI4+UJwC7qbVlh5zfhj8oTNUXgN0AOc+Q0/WFPl1aw5VV/VrO8FCoB15lFVlpKaQ1Yh+DVU8ke+rt9Th0BCHXe0uZOEmH0nOnH/0onD PyCharm1IHMWLMSEAL-eyJsaWNlbnNlSWQiOiJJSE1XTE1TRUFMIiwibGljZW5zZWVOYW1lIjoidHJlbmRzIHJhYmJpcyIsImFzc2lnbmVlTmFtZSI6IiIsImFzc2lnbmVlRW1haWwiOiIiLCJsaWNlbnNlUmVzdHJpY3Rpb24iOiIiLCJjaGVja0NvbmN1cnJlbnRVc2UiOmZhbHNlLCJwcm9kdWN0cyI6W3siY29kZSI6IlBDIiwiZmFsbGJhY2tEYXRlIjoiMjAyMy0wMi0wOCIsInBhaWRVcFRvIjoiMjAyMy0wMi0wOCIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiUFBDIiwiZmFsbGJhY2tEYXRlIjoiMjAyMy0wMi0wOCIsInBhaWRVcFRvIjoiMjAyMy0wMi0wOCIsImV4dGVuZGVkIjp0cnVlfSx7ImNvZGUiOiJQV1MiLCJmYWxsYmFja0RhdGUiOiIyMDIzLTAyLTA4IiwicGFpZFVwVG8iOiIyMDIzLTAyLTA4IiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IlBTSSIsImZhbGxiYWNrRGF0ZSI6IjIwMjMtMDItMDgiLCJwYWlkVXBUbyI6IjIwMjMtMDItMDgiLCJleHRlbmRlZCI6dHJ1ZX0seyJjb2RlIjoiUENXTVAiLCJmYWxsYmFja0RhdGUiOiIyMDIzLTAyLTA4IiwicGFpZFVwVG8iOiIyMDIzLTAyLTA4IiwiZXh0ZW5kZWQiOnRydWV9XSwibWV0YWRhdGEiOiIwMTIwMjIwMjA4UFNBTjAwMDAwNSIsImhhc2giOiJUUklBTDozMzQzMzQ3ODMiLCJncmFjZVBlcmlvZERheXMiOjcsImF1dG9Qcm9sb25nYXRlZCI6ZmFsc2UsImlzQXV0b1Byb2xvbmdhdGVkIjpmYWxzZX0=-TT/mvlYqIE07j8qgnrhSSVpMtD4buKsRuntPuB17Zb8KodU2SUcb8byLpLG1pU+xEIIyG3Scu/ypjXmQ9w4iyvOT+NYGmeeHFMHnknQVEhhUvDZjTMNXPct03KeHcjxJX8jMSsuRkTooePx1beXjHTuxcyiO8qJcNOOl/97pT45kGTqSJohat0Xe7oiwrE6u3JZhfSdmYV9iJxz6XGNeoPMPnXbH17yoP75eXUqQJzUGxqdeHyKVHSUUJTGfO3IHgjN9y2TwYET5oFjRy1qSMRf4vXpPCK7tnfqhCGISQiDCm+ETB133CcmArxlRVlKdbAIM/7W++eOn5AfW/CNvgg==-MIIETDCCAjSgAwIBAgIBDTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTIwMTAxOTA5MDU1M1oXDTIyMTAyMTA5MDU1M1owHzEdMBsGA1UEAwwUcHJvZDJ5LWZyb20tMjAyMDEwMTkwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCUlaUFc1wf+CfY9wzFWEL2euKQ5nswqb57V8QZG7d7RoR6rwYUIXseTOAFq210oMEe++LCjzKDuqwDfsyhgDNTgZBPAaC4vUU2oy+XR+Fq8nBixWIsH668HeOnRK6RRhsr0rJzRB95aZ3EAPzBuQ2qPaNGm17pAX0Rd6MPRgjp75IWwI9eA6aMEdPQEVN7uyOtM5zSsjoj79Lbu1fjShOnQZuJcsV8tqnayeFkNzv2LTOlofU/Tbx502Ro073gGjoeRzNvrynAP03pL486P3KCAyiNPhDs2z8/COMrxRlZW5mfzo0xsK0dQGNH3UoG/9RVwHG4eS8LFpMTR9oetHZBAgMBAAGjgZkwgZYwCQYDVR0TBAIwADAdBgNVHQ4EFgQUJNoRIpb1hUHAk0foMSNM9MCEAv8wSAYDVR0jBEEwP4AUo562SGdCEjZBvW3gubSgUouX8bOhHKQaMBgxFjAUBgNVBAMMDUpldFByb2ZpbGUgQ0GCCQDSbLGDsoN54TATBgNVHSUEDDAKBggrBgEFBQcDATALBgNVHQ8EBAMCBaAwDQYJKoZIhvcNAQELBQADggIBAB2J1ysRudbkqmkUFK8xqhiZaYPd30TlmCmSAaGJ0eBpvkVeqA2jGYhAQRqFiAlFC63JKvWvRZO1iRuWCEfUMkdqQ9VQPXziE/BlsOIgrL6RlJfuFcEZ8TK3syIfIGQZNCxYhLLUuet2HE6LJYPQ5c0jH4kDooRpcVZ4rBxNwddpctUO2te9UU5/FjhioZQsPvd92qOTsV+8Cyl2fvNhNKD1Uu9ff5AkVIQn4JU23ozdB/R5oUlebwaTE6WZNBs+TA/qPj+5/we9NH71WRB0hqUoLI2AKKyiPw++FtN4Su1vsdDlrAzDj9ILjpjJKA1ImuVcG329/WTYIKysZ1CWK3zATg9BeCUPAV1pQy8ToXOq+RSYen6winZ2OO93eyHv2Iw5kbn1dqfBw1BuTE29V2FJKicJSu8iEOpfoafwJISXmz1wnnWL3V/0NxTulfWsXugOoLfv0ZIBP1xH9kmf22jjQ2JiHhQZP7ZDsreRrOeIQ/c4yR8IQvMLfC0WKQqrHu5ZzXTH4NO3CwGWSlTY74kE91zXB5mwWAx1jig+UXYc2w4RkVhy0//lOmVya/PEepuuTTI4+UJwC7qbVlh5zfhj8oTNUXgN0AOc+Q0/WFPl1aw5VV/VrO8FCoB15lFVlpKaQ1Yh+DVU8ke+rt9Th0BCHXe0uZOEmH0nOnH/0onD PHPStorm1WC8O5PZ8P1-eyJsaWNlbnNlSWQiOiJXQzhPNVBaOFAxIiwibGljZW5zZWVOYW1lIjoidHJlbmRzIHJhYmJpcyIsImFzc2lnbmVlTmFtZSI6IiIsImFzc2lnbmVlRW1haWwiOiIiLCJsaWNlbnNlUmVzdHJpY3Rpb24iOiIiLCJjaGVja0NvbmN1cnJlbnRVc2UiOmZhbHNlLCJwcm9kdWN0cyI6W3siY29kZSI6IlBTIiwiZmFsbGJhY2tEYXRlIjoiMjAyMy0wMi0wOCIsInBhaWRVcFRvIjoiMjAyMy0wMi0wOCIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiUFBTIiwiZmFsbGJhY2tEYXRlIjoiMjAyMy0wMi0wOCIsInBhaWRVcFRvIjoiMjAyMy0wMi0wOCIsImV4dGVuZGVkIjp0cnVlfSx7ImNvZGUiOiJQV1MiLCJmYWxsYmFja0RhdGUiOiIyMDIzLTAyLTA4IiwicGFpZFVwVG8iOiIyMDIzLTAyLTA4IiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IlBTSSIsImZhbGxiYWNrRGF0ZSI6IjIwMjMtMDItMDgiLCJwYWlkVXBUbyI6IjIwMjMtMDItMDgiLCJleHRlbmRlZCI6dHJ1ZX0seyJjb2RlIjoiUENXTVAiLCJmYWxsYmFja0RhdGUiOiIyMDIzLTAyLTA4IiwicGFpZFVwVG8iOiIyMDIzLTAyLTA4IiwiZXh0ZW5kZWQiOnRydWV9XSwibWV0YWRhdGEiOiIwMTIwMjIwMjA4UFNBTjAwMDAwNSIsImhhc2giOiJUUklBTDoxMDQ2MTY0OTY5IiwiZ3JhY2VQZXJpb2REYXlzIjo3LCJhdXRvUHJvbG9uZ2F0ZWQiOmZhbHNlLCJpc0F1dG9Qcm9sb25nYXRlZCI6ZmFsc2V9-WW4JPvzhkKSGWoY98a/86WA0TzER4DaNvfj4oSxagfZnX0gwI4Z7hR4b+M5FSiP19NhqSVcatS0YK9t8wpr5iqXVsxWLdO9BnG5spy4SlC9vU8PgRqnSc8lkGv7+++q+FSfX6lh9EIDLxvsMdffjSpCAFfviHGNstBsTpbC0LlewYWZebzLvMA0n8OMKj/BDkh/WKOyF33E7QOBMjXMct8Pp8UrJF03IG/BJ2gCrVIaCGnwsArmVFwaCVZbrXOQFYZaqf+NiuYZztYrnz1c8VFAp0IMfJ7qNsKn+kI3pdwCbCZQAkQPDFCoYbRXUGISPCM/EHjYU+qzeAqSZOcSJzA==-MIIETDCCAjSgAwIBAgIBDTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTIwMTAxOTA5MDU1M1oXDTIyMTAyMTA5MDU1M1owHzEdMBsGA1UEAwwUcHJvZDJ5LWZyb20tMjAyMDEwMTkwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCUlaUFc1wf+CfY9wzFWEL2euKQ5nswqb57V8QZG7d7RoR6rwYUIXseTOAFq210oMEe++LCjzKDuqwDfsyhgDNTgZBPAaC4vUU2oy+XR+Fq8nBixWIsH668HeOnRK6RRhsr0rJzRB95aZ3EAPzBuQ2qPaNGm17pAX0Rd6MPRgjp75IWwI9eA6aMEdPQEVN7uyOtM5zSsjoj79Lbu1fjShOnQZuJcsV8tqnayeFkNzv2LTOlofU/Tbx502Ro073gGjoeRzNvrynAP03pL486P3KCAyiNPhDs2z8/COMrxRlZW5mfzo0xsK0dQGNH3UoG/9RVwHG4eS8LFpMTR9oetHZBAgMBAAGjgZkwgZYwCQYDVR0TBAIwADAdBgNVHQ4EFgQUJNoRIpb1hUHAk0foMSNM9MCEAv8wSAYDVR0jBEEwP4AUo562SGdCEjZBvW3gubSgUouX8bOhHKQaMBgxFjAUBgNVBAMMDUpldFByb2ZpbGUgQ0GCCQDSbLGDsoN54TATBgNVHSUEDDAKBggrBgEFBQcDATALBgNVHQ8EBAMCBaAwDQYJKoZIhvcNAQELBQADggIBAB2J1ysRudbkqmkUFK8xqhiZaYPd30TlmCmSAaGJ0eBpvkVeqA2jGYhAQRqFiAlFC63JKvWvRZO1iRuWCEfUMkdqQ9VQPXziE/BlsOIgrL6RlJfuFcEZ8TK3syIfIGQZNCxYhLLUuet2HE6LJYPQ5c0jH4kDooRpcVZ4rBxNwddpctUO2te9UU5/FjhioZQsPvd92qOTsV+8Cyl2fvNhNKD1Uu9ff5AkVIQn4JU23ozdB/R5oUlebwaTE6WZNBs+TA/qPj+5/we9NH71WRB0hqUoLI2AKKyiPw++FtN4Su1vsdDlrAzDj9ILjpjJKA1ImuVcG329/WTYIKysZ1CWK3zATg9BeCUPAV1pQy8ToXOq+RSYen6winZ2OO93eyHv2Iw5kbn1dqfBw1BuTE29V2FJKicJSu8iEOpfoafwJISXmz1wnnWL3V/0NxTulfWsXugOoLfv0ZIBP1xH9kmf22jjQ2JiHhQZP7ZDsreRrOeIQ/c4yR8IQvMLfC0WKQqrHu5ZzXTH4NO3CwGWSlTY74kE91zXB5mwWAx1jig+UXYc2w4RkVhy0//lOmVya/PEepuuTTI4+UJwC7qbVlh5zfhj8oTNUXgN0AOc+Q0/WFPl1aw5VV/VrO8FCoB15lFVlpKaQ1Yh+DVU8ke+rt9Th0BCHXe0uZOEmH0nOnH/0onD 其他 更多详见：Jetbrains 其他产品对应激活码 &amp;#8211; 小黑说","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhukejin.com/categories/JavaScript/"}],"tags":[{"name":"tnt","slug":"tnt","permalink":"https://zhukejin.com/tags/tnt/"}]},{"title":"如何关闭 Alfred 的同步功能","slug":"close-alfred-sync","date":"un44fin44","updated":"un00fin00","comments":true,"path":"2021/close-alfred-sync/","permalink":"https://zhukejin.com/2021/close-alfred-sync/","excerpt":"个人感觉 Alfred 提供的同步功能十分鸡肋，在尝试了一番后，两个设备的 workFlow 都出现了不同的问题。 因为两台电脑的环境可能不同，自定义的 workflow 中，package 可能也会找不到。","text":"个人感觉 Alfred 提供的同步功能十分鸡肋，在尝试了一番后，两个设备的 workFlow 都出现了不同的问题。 因为两台电脑的环境可能不同，自定义的 workflow 中，package 可能也会找不到。 然鹅界面中并没有关闭 sync 功能的入口，只能通过命令来实现： 一、退出alfred 主程序二、终端执行命令1rm -rf ~/Library/Application\\ Support/Alfred/prefs.json 重启 Alfred 即可","categories":[{"name":"Other","slug":"Other","permalink":"https://zhukejin.com/categories/Other/"}],"tags":[{"name":"Tool","slug":"Tool","permalink":"https://zhukejin.com/tags/Tool/"}]},{"title":"打造超强终端！","slug":"Create-super-terminal","date":"un22fin22","updated":"un00fin00","comments":true,"path":"2021/Create-super-terminal/","permalink":"https://zhukejin.com/2021/Create-super-terminal/","excerpt":"工欲善其事，必先利其器！ 本文将从一个 MacOS 新机开始，一步步搭建一个简单、易用、强大的前端开发环境！","text":"工欲善其事，必先利其器！ 本文将从一个 MacOS 新机开始，一步步搭建一个简单、易用、强大的前端开发环境！ 终端增强iTerm2iTerm2 是一个增强型终端，功能比自带的 Terminal 更强大，在最新的版本中 shell 环境已默认为 zsh。 可以直接在官网下载 https://iterm2.com/downloads.html oh my zshOh My Zsh 是一款 zsh 的增强工具 1sh -c &quot;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot; 如果提示 curl 未安装，可以用 wget 来安装 1sh -c &quot;$(wget https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh -O -)&quot; 如果提示网络、SSL 错误，可以单独在浏览器中打开 https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh将 shell 脚本保存下来，在本地执行 P10KP10K 全名 powerlevel10k, 是一款 iterm2 的主题管理工具，可以通过它来个性化你的 iTerm2 安装脚本 1git clone --depth=1 https://gitee.com/romkatv/powerlevel10k.git $&#123;ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom&#125;/themes/powerlevel10k 然后 vim ~/.zshrc，搜索 ZSH_THEME，将主题设置为 powerlevel10k/powerlevel10k 1ZSH_THEME=&quot;powerlevel10k/powerlevel10k&quot; 完毕后，重启终端，会默认进行 p10k的配置。 后续也可以通过 p10k configure 随时修改配置。 zsh 插件zsh-autosuggestions一个命令自动补全插件 1git clone https://github.com/zsh-users/zsh-autosuggestions $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-autosuggestions zsh-syntax-highlighting一个命令行高亮插件 1git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting 安装完毕后记得把插件添加到 .zshrc 配置中，zsh-syntax-highlighting 插件比较特殊，记得一定要放在最后一个 12345plugins=( # other plugins... zsh-autosuggestions zsh-syntax-highlighting) Brew 安装官网文档 Brew 可以理解为 MacOS 的包、软件管理系统，底层使用 Ruby(MacOS 已自带) 实现，在日常开发中，可以通过brew install xxx 来安装软件。 Brew 的默认资源存储在 raw.githubusercontent.com 中，国内龟速，因此我们可以通过 gitee 的镜像来进行 Brew 的初始安装，以及通过 bottles 镜像来为 install 行为提速 详见之前的文章：如何为 Brew 提速 NVM 安装node 版本管理工具，大家都懂~ 1curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.1/install.sh | bash 国内镜像：https://gitee.com/mirrors/nvm/tree/master 安装完毕后，一般会自动设置node 环境，可在 .zshrc 中检查是否在末尾已添加： 12export NVM_DIR=&quot;$([ -z &quot;$&#123;XDG_CONFIG_HOME-&#125;&quot; ] &amp;&amp; printf %s &quot;$&#123;HOME&#125;/.nvm&quot; || printf %s &quot;$&#123;XDG_CONFIG_HOME&#125;/nvm&quot;)&quot;[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \\. &quot;$NVM_DIR/nvm.sh&quot; # This loads nvm 重启终端或 source .zshrc。 NRM 安装相比与 NVM， NRM 知名度不是很高，它的作用也非常简单：随时切换node 仓库源。 例子： 123npm install -g nrmnrm lsnrm use cnpm Python PIP 源Mac OS 已自动 python2、3，所以只需要切换一下源就ok 了 12# 清华源pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple 其他可用源： http://pypi.douban.com/simple/ 豆瓣 http://mirrors.aliyun.com/pypi/simple/ 阿里 http://pypi.hustunique.com/simple/ 华中理工大学 http://pypi.sdutlinux.org/simple/ 山东理工大学 http://pypi.mirrors.ustc.edu.cn/simple/ 中国科学技术大学","categories":[{"name":"Other","slug":"Other","permalink":"https://zhukejin.com/categories/Other/"}],"tags":[{"name":"Tool","slug":"Tool","permalink":"https://zhukejin.com/tags/Tool/"}]},{"title":"如何给 Brew 提速？","slug":"Making-Brew-faster-and-faster","date":"un33fin33","updated":"un00fin00","comments":true,"path":"2021/Making-Brew-faster-and-faster/","permalink":"https://zhukejin.com/2021/Making-Brew-faster-and-faster/","excerpt":"","text":"国内优秀镜像源有很多，譬如清华源、中科大源、阿里源、腾讯源等 目前使用对比下来，在上海电信网络中，阿里云最快。 修改 Brew 自身的 git 仓库目的是为了给 brew update 这样的命令提速，这里采用阿里的仓库 12345cd &quot;$(brew --repo)&quot;git remote set-url origin https://mirrors.aliyun.com/homebrew/brew.git# 原始仓库# git remote set-url origin https://github.com/Homebrew/brew.git 修改 homebrew-core 的git 仓库homebrew-core 是 Homebrew 核心软件仓库 123456cd &quot;$(brew --repo)/Library/Taps/homebrew/homebrew-core&quot;git remote set-url origin https://mirrors.aliyun.com/homebrew/homebrew-core.gitbrew update# 原始仓库# git remote set-url origin https://github.com/Homebrew/homebrew-core.git 修改 homebrew-cask 的git 仓库123456cd &quot;$(brew --repo)/Library/Taps/homebrew/homebrew-cask&quot;git remote set-url origin https://mirrors.aliyun.com/homebrew/homebrew-cask.gitbrew update# 原始仓库# git remote set-url origin https://github.com/Homebrew/homebrew-cask.git 修改 homebrew-bottles 的镜像源目的是给 brew install xxx 这样的命令提速，以 zsh 为例 12echo &#x27;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.aliyun.com/homebrew/homebrew-bottles&#x27; &gt;&gt; ~/.zshrcsource ~/.zshrc 参考 Homebrew Core 源使用帮助 &amp;mdash; USTC Mirror Help 文档 Homebrew Bottles 源使用帮助 &amp;mdash; USTC Mirror Help 文档 homebrew | 镜像站使用帮助 | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror","categories":[{"name":"Other","slug":"Other","permalink":"https://zhukejin.com/categories/Other/"}],"tags":[{"name":"Tool","slug":"Tool","permalink":"https://zhukejin.com/tags/Tool/"}]},{"title":"如何将下划线格式与驼峰格式互换","slug":"underScoreCase-to-CamelCase","date":"un33fin33","updated":"un00fin00","comments":true,"path":"2021/underScoreCase-to-CamelCase/","permalink":"https://zhukejin.com/2021/underScoreCase-to-CamelCase/","excerpt":"","text":"场景1现有一个需求，要将返回值中所有涉及到下划线风格的数据全部转化为驼峰风格，如： 123456&#123; &quot;records_total&quot;: 200, &quot;data&quot;: &#123; &quot;indexId&quot;: 2 &#125;&#125; 更改为： 123456&#123; &quot;recordsTotal&quot;: 200, &quot;data&quot;: &#123; &quot;indexId&quot;: 2 &#125;&#125; 然而此时我们程序中已经使用了大量的返回值变量， 那可以对返回值进行处理，将下划线变为驼峰，如： 123456789101112131415161718request(api.infoTypeSearch).subscribe(res =&gt; &#123; const newData = res.data.map((item: any) =&gt; &#123; let newObj:&#123;[string]: any&#125; = &#123;&#125; Object.keys(item).forEach(key =&gt; &#123; newObj[this.toHump(key)] = item[key] &#125;) return newObj &#125;)&#125;)......toHump (name: string): string &#123; return name.replace(/\\_(\\w)/g, function(all, letter)&#123; return letter.toUpperCase(); &#125;);&#125; 场景二好家伙！文件中使用了大量不规范的下划线命名，如何一步将其全变为驼峰？ 借助 IDE 的正则替换功能（如果你的编辑器没有这个功能， 那你就复制出来用 string 操作吧） Webstorm 按 shift + command + R，进入替换模式 选择正则替换 输入 _(\\w) 替换为 \\U$1 替换即可 Tips替换为小写则是： \\L$1","categories":[{"name":"Other","slug":"Other","permalink":"https://zhukejin.com/categories/Other/"}],"tags":[]},{"title":"关于 Homebrew 的一些小技巧","slug":"about-homebrew","date":"un11fin11","updated":"un00fin00","comments":true,"path":"2021/about-homebrew/","permalink":"https://zhukejin.com/2021/about-homebrew/","excerpt":"Homebrew 是什么? brew 安装问题资源被墙由于 GFW 的存在，某些时候可能会导致如下报错 12curl: (7) Failed to connect to raw.githubusercontent.com port 443: Connection refused","text":"Homebrew 是什么? brew 安装问题资源被墙由于 GFW 的存在，某些时候可能会导致如下报错 12curl: (7) Failed to connect to raw.githubusercontent.com port 443: Connection refused 解决方法使用代理如在开启 sock5 代理后，在安装命令后加上代理地址： 1/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install -x 127.0.0.1:1087)&quot; 或使用全局代理绑定： 12export ALL_PROXY=socks5://127.0.0.1:1087 /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; brew 如何使用基础用法1234567891011121314151617181920212223242526272829303132// 搜索包brew search mysql// 安装包brew install mysql// 查看包信息，比如目前的版本，依赖，安装后注意事项等brew info mysql// 卸载包brew uninstall wget// 显示已安装的包brew list// 查看brew的帮助brew –help// 更新， 这会更新 Homebrew 自己brew update// 检查过时（是否有新版本），这会列出所有安装的包里，哪些可以升级brew outdatedbrew outdated mysql// 升级所有可以升级的软件们brew upgradebrew upgrade mysql// 清理不需要的版本极其安装包缓存brew cleanupbrew cleanup mysql brew caskbrew cask 可以额外安装 GUI 软件，如: 1brew cask install dingtalk brew cask 相比 brew 新增的命令： 1234567891011brew cask audit查询指定 Cask 的可安装性brew cask cat查看指定 Cask 安装源信息brew cask zap打包指定 Caskbrew cask cleanup清理缓存及软链 Tips如果安装一半 alt + z 关掉了，下次再使用 cask 的时候会提示： 1Error: Another active Homebrew update process is already in progress. 原因是在安装的时候，brew 会生成 locks 文件，删除锁定即可 1rm -rf /usr/local/var/homebrew/locks 参考文档 https://www.jianshu.com/p/61f209cd0e91https://www.jianshu.com/p/bca8fc1ff3f0","categories":[{"name":"Other","slug":"Other","permalink":"https://zhukejin.com/categories/Other/"}],"tags":[{"name":"Tool","slug":"Tool","permalink":"https://zhukejin.com/tags/Tool/"}]},{"title":"提高工作效率的工具集(第一期)","slug":"productivity-tools","date":"un22fin22","updated":"un00fin00","comments":true,"path":"2021/productivity-tools/","permalink":"https://zhukejin.com/2021/productivity-tools/","excerpt":"消灭重复劳动 Dash 一个用于快速查询在线文档的工具, 支持离线文档，Google、Stack Overflow","text":"消灭重复劳动 Dash 一个用于快速查询在线文档的工具, 支持离线文档，Google、Stack Overflow 软件截图： UTool 一个系统级的底座插件，类似 Alfred, 但是它是免费的脚本使用 JavaScript，可以达到软件快开、插件使用、自动脚本等功能 一切皆插件 启动已安装的程序仅仅是最基础的功能，uTools 最大的特点就是拥有强大的插件系统，我们可以用插件来实现什么功能？ 自动创建 PM 定时任务、自动统计今日工时，并生成 Excel 表格并发送邮件 去除网站广告 复制后，自动上传到云笔记、图床 等等 支持特性 视窗操作 文件操作 粘贴板操作 可编程浏览器 可编程浏览器 亮点函数： evaluate 在网页内执行回调 wait 延迟执行 click 点击元素 scroll 视窗滚动 simulateKeyboardTap 模拟键鼠操作 .db 本地数据库 场景举例 ex1: 打开 PM 系统，并自动统计今日任务，复制到粘贴板12345// 打开&quot;必应&quot; 并搜索 &quot;uTools&quot;utools.ubrowser.goto(&#x27;https://cn.bing.com&#x27;) .value(&#x27;#sb_form_q&#x27;, &#x27;uTools&#x27;) .click(&#x27;#sb_form_go&#x27;) .run(&#123; width: 1000, height: 600 &#125;) ex2: 打开 PM 系统，并自动统计今日任务，复制到粘贴板1234/** ubrowser: 此对象封装了常见的 JavaScript DOM 操作，包括修改css、Dom、截图、生成 PDF、操作Cookie 等*/utools.ubrowser.goto(&#x27;https://pm.nexttao.com/time_entries?query_id=1254&amp;isCountTime=true&#x27;) 软件截图： Tampermonkey工作原理： 通过底座插件的形式安装到浏览器中，用户可以基于底座开发 JavaScript 脚本，从而控制浏览器执行对应的命令。 与 UTool 不同的是， Tampermonkey 专注于浏览器，理论上在浏览器端，TamperMonkey 是无所不能的。 支持的浏览器： Chrome Firefox Safari Edge Opera 等 可以用来做什么？ PM 自动化 各种网站限制破解 屏蔽各种网站广告，类似 AdBlock 功能 配合服务端，可以达到属于自己的剪影工具 电商网站关注列表的价格波动 去除知乎、豆瓣的二次重定向 火车票自动抢票 … ex1: 今日任务自动统计脚本12345678910111213141516171819 function getReport () &#123; let num = 1; let data = $(&#x27;table.time-entries tbody tr&#x27;).map((key, item) =&gt; &#123; const id = $(item).find(&#x27;.issue .issue&#x27;).text(); const subject = $(item).find(&#x27;td.issue&#x27;).text(); const comments = $(item).find(&#x27;.comments&#x27;).text(); return `$&#123;num++&#125;. $&#123;comments ? comments : subject&#125; (100%)` &#125;); const text = [].slice.call(data).join(``) if (text) &#123; copyTextToClipboard(text) &#125; &#125; ex2: 一键创建 PM123456789101112131415161718// 此间数据都可以作为图形化界面配置存储function addPm (title, time) &#123; $(&#x27;#issue_tracker_id&#x27;).val(&#x27;2&#x27;) $(&#x27;#issue_subject&#x27;).val(title) $(&#x27;#issue_due_date&#x27;).val(&#x27;2020-11-27&#x27;) $(&#x27;#issue_custom_field_values_18&#x27;).val(&#x27;2020-11-27&#x27;) $(&#x27;#issue_estimated_hours&#x27;).val(time) $(&#x27;#issue_assigned_to_id&#x27;).val(292) $(&#x27;#issue_fixed_version_id&#x27;).val(&#x27;1133&#x27;)&#125;;addPm(&#x27;扫描结果(商品列表)&#x27;, 4); $(&#x27;input[name=continue]&#x27;).click() AppleMator介绍 类似手机上的捷径Automator是Mac系统上的一个原生程序，图标是一个小机器人，你可以用它来创造一系列工作流（Workflow），用来执行一些简单或者复杂的任务，比如批量更改文件名，合并多个PDF文档，或者利用QuickTime转换视频的格式，等等。 软件截图 使用场景 PDF 识别、转 Word (上面截图) 键盘模拟、自动点击等 定时任务，关机 自动清理垃圾 大文件检测 等等 AppleScript Mac 自己的脚本语言，已引入 JavaScript 支持 软件截图 截图脚本实现了： 读取待办事项 处理数据 -&gt; 发送邮件 脚本亮点 原生支持，和Mac 系统契合度高 OC 交互，可以调用 Objective-C 的函数和库 与 AutoMator 结合 例子 ex: 读取当前激活的浏览器标签123456789101112131415161718const chrome = Application(&#x27;Google Chrome&#x27;);const tabs = chrome.windows.tabs;const snapshot = [];for (const tabId in tabs) &#123; const title = tabs[tabId].title(); const url = tabs[tabId].url(); snapshot.push(&#123; title, url &#125;);&#125;ObjC.import(&#x27;Foundation&#x27;);const fm = $.NSFileManager.defaultManager;fm[&#x27;createFileAtPath:contents:attributes:&#x27;]( &#x27;/tmp/snapshot.json&#x27;, JSON.stringify(snapshot, null, &#x27; &#x27;), $());","categories":[{"name":"Other","slug":"Other","permalink":"https://zhukejin.com/categories/Other/"}],"tags":[{"name":"Tool","slug":"Tool","permalink":"https://zhukejin.com/tags/Tool/"}]},{"title":"记一次奇怪的 WebStorm 闪退问题","slug":"Mac-Webstorm-Crash","date":"un22fin22","updated":"un00fin00","comments":true,"path":"2021/Mac-Webstorm-Crash/","permalink":"https://zhukejin.com/2021/Mac-Webstorm-Crash/","excerpt":"现象在 19.3 -&gt; 20.3.3 版本升级过程中， 打开新版本 webstorm 后， 立即闪退(未出现软件 GUI) 原因排查","text":"现象在 19.3 -&gt; 20.3.3 版本升级过程中， 打开新版本 webstorm 后， 立即闪退(未出现软件 GUI) 原因排查 进入 /Applications/WebStorm.app/Contents/MacOS 目录，其中有一个可执行文件 webstorm 执行此文件自检，输出： 12345678910112021-04-06 10:13:16.115 webstorm[7279:53124] allVms required 1.8*,1.8+2021-04-06 10:13:16.117 webstorm[7279:53129] Current Directory: /Users/zhu2021-04-06 10:13:16.117 webstorm[7279:53129] Value of WEBSTORM_VM_OPTIONS is (null)2021-04-06 10:13:16.117 webstorm[7279:53129] Processing VMOptions file at /Users/zhu/Library/Application Support/JetBrains/WebStorm2020.3/webstorm.vmoptions2021-04-06 10:13:16.117 webstorm[7279:53129] DoneOpenJDK 64-Bit Server VM warning: Option UseConcMarkSweepGC was deprecated in version 9.0 and will likely be removed in a future release.Error opening zip file or JAR manifest missing : /Applications/WebStorm.app/Contents/tnt/jetbrains-agent.jarError occurred during initialization of VMagent library failed to init: instrumentSaving session...completed.Deleting expired sessions... 23 completed. 看其中 Error 信息是缺少了 一个 jar 包， 回忆一下~，这玩意是 TNT 残留，囧。为何卸载程序后， vm 配置还在？ 哦原来 vm 配置是在 Library&#x2F;Application Support 中 解决办法1vim /Users/zhu/Library/Application Support/JetBrains/WebStorm2020.3/webstorm.vmoptions 移除tnt 配置，重新启动即可","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhukejin.com/categories/JavaScript/"}],"tags":[]},{"title":"upgrade-nvm","slug":"upgrade-nvm","date":"un44fin44","updated":"un00fin00","comments":true,"path":"2021/upgrade-nvm/","permalink":"https://zhukejin.com/2021/upgrade-nvm/","excerpt":"NVM 如何升级在尝试通过重新安装 NVM 来达到更新的目的时，发现了一个提示 12=&gt; nvm is already installed in /Users/xxx/.nvm, trying to update using git=&gt; Failed to update nvm, run &#x27;git fetch&#x27; in /Users/xxx/.nvm yourself. 但是进入到 &#x2F;Users&#x2F;xxx&#x2F;.nvm 中发现这里虽然是一个git 仓库，但是却没有分支，只有 commit 号，所以也没办法通过 git pull 的方式来进行更新","text":"NVM 如何升级在尝试通过重新安装 NVM 来达到更新的目的时，发现了一个提示 12=&gt; nvm is already installed in /Users/xxx/.nvm, trying to update using git=&gt; Failed to update nvm, run &#x27;git fetch&#x27; in /Users/xxx/.nvm yourself. 但是进入到 &#x2F;Users&#x2F;xxx&#x2F;.nvm 中发现这里虽然是一个git 仓库，但是却没有分支，只有 commit 号，所以也没办法通过 git pull 的方式来进行更新 在官方 github issue 中发现以下解决方案： 123456789101112#!/bin/shset -ecd ~/.nvmgit fetch --tagsTAG=$(git describe --tags `git rev-list --tags --max-count=1`)echo &quot;Checking out tag $TAG...&quot;git checkout &quot;$TAG&quot;source ~/.nvm/nvm.sh","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhukejin.com/categories/JavaScript/"}],"tags":[{"name":"NPM","slug":"NPM","permalink":"https://zhukejin.com/tags/NPM/"}]},{"title":"node-sass 权限报错问题","slug":"node-sass-error","date":"un44fin44","updated":"un00fin00","comments":true,"path":"2020/node-sass-error/","permalink":"https://zhukejin.com/2020/node-sass-error/","excerpt":"","text":"记录 此问题出现次数较多，特此记录 出现 gyp 错误、权限错误原因是由于 Mac 的权限策略导致，需要创建高级用户，或者使用非安全模式 解决方案： 1sudo npm install -g --unsafe-perm node-sass","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhukejin.com/categories/JavaScript/"}],"tags":[{"name":"NPM","slug":"NPM","permalink":"https://zhukejin.com/tags/NPM/"}]},{"title":"css-priority","slug":"css-priority","date":"un22fin22","updated":"un00fin00","comments":true,"path":"2020/css-priority/","permalink":"https://zhukejin.com/2020/css-priority/","excerpt":"CSS 选择器优先级优先级规则浏览器将样式表划分为四个级别，A、B、C、D 如果存在内联样式 A 记为 1，否则记为 0 B 代表该样式表达式中 ID 选择器的个数 C 代表类、伪类、属性选择器的个数 D 代表 标签、伪元素个数 比较规则将ABCD 组成四位数，比较大小即可，如样式1 的ABCD 规则计算结果是 0111，样式 2 的计算结果是 0011 则代表样式1 的优先级高于样式2。","text":"CSS 选择器优先级优先级规则浏览器将样式表划分为四个级别，A、B、C、D 如果存在内联样式 A 记为 1，否则记为 0 B 代表该样式表达式中 ID 选择器的个数 C 代表类、伪类、属性选择器的个数 D 代表 标签、伪元素个数 比较规则将ABCD 组成四位数，比较大小即可，如样式1 的ABCD 规则计算结果是 0111，样式 2 的计算结果是 0011 则代表样式1 的优先级高于样式2。 例子1234567891011121314151617&lt;style&gt; .red span &#123; /* A0 B0 C1 D1 */ color: black; &#125; #red1 &#123; /* A0 B1 C0 D0 */ color: red; &#125; &lt;/style&gt; &lt;div id=&quot;red&quot; class=&quot;red&quot;&gt; &lt;span id=&quot;red1&quot;&gt; 你好 &lt;/span&gt; &lt;/div&gt; 此时通过上述规则发现 0011 &lt; 0100，所以 #red1 的样式生效。 提示，上述规则仅适合自身元素样式比较，继承来的属性优先级最低， !import 的优先级最高","categories":[{"name":"CSS","slug":"CSS","permalink":"https://zhukejin.com/categories/CSS/"}],"tags":[]},{"title":"component design specification","slug":"component-design-specification","date":"un22fin22","updated":"un00fin00","comments":true,"path":"2020/component-design-specification/","permalink":"https://zhukejin.com/2020/component-design-specification/","excerpt":"设计基础 字体 排版 色彩 交互原则 组件原则 高效 轻量 低耦 独立 易用 组件定义基础服务组件 排版 （栅格组件） 动画组件 基础通用组件 Button Icon Loading 浮层","text":"设计基础 字体 排版 色彩 交互原则 组件原则 高效 轻量 低耦 独立 易用 组件定义基础服务组件 排版 （栅格组件） 动画组件 基础通用组件 Button Icon Loading 浮层 导航组件 Menu Breadcrumb Pagination Steps 交互组件 Alert Message Modal 表单组件 Form Input Radio CheckBox Select Switch DatePicker 数据呈现型组件 Card Badge Table Tag TimeLine Tooltip 开发方式渐进式开发剥离 CSS 与 组件的耦合性，将CSS 独立为CSS库。 组件开发规范1. 组件分离 每个组件单独一个文件夹 在父级建立统一入口 index.ts，由应用方通过 AppModule 导入：如 import &#123; NgModule &#125; from &#39;@angular/core&#39;; import &#123; ButtonsModule &#125; from &#39;./buttons&#39;; @NgModule(&#123; exports: [ ButtonsModule ], &#125;) export class pingUIModules &#123; &#125; 2. 独立调用 在文件夹外部，应单独暴露出某个组件，以便用户独立调用。如在Component 目录下的 Buttons 同级目录下建立 buttons.ts: export &#123; ButtonComponent &#125; from &#39;./buttons/button.component&#39;; export &#123; ButtonsModule &#125; from &#39;./buttons/buttons.module&#39;; 3. 公共部分 将组件都可以用到的公共部分抽象化 4. 组件构成 每个组件应当由下列文件构成: [name].component.html 模板文件 [name].module.ts 模块文件 [name].component.ts 组件类 [name].component.spec.ts //若需要Karma测试 readme.md 使用文档 [name].d.ts 文件，若需要 编码规范 文件夹、文件名全部小写 内部文件以 [name].component.ts 这样的风格命名 文件内部的类名以 首字母大写的驼峰式 命名 文件的模块化导入导出使用 Es6 规范，不要使用 Webpack、CommonJs 等库风格的 Require() 全部使用4格缩进 其他规范详情参考 https://github.com/fex-team/styleguide/blob/master/javascript.md 团队尽量保持一个简单、易读、语义化、清晰的风格","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhukejin.com/categories/JavaScript/"}],"tags":[{"name":"Design","slug":"Design","permalink":"https://zhukejin.com/tags/Design/"}]},{"title":"关于 Rxjs 中 Reduce Scan 的区别","slug":"关于-Rxjs-中-Reduce-Scan-的区别","date":"un11fin11","updated":"un00fin00","comments":true,"path":"2019/关于-Rxjs-中-Reduce-Scan-的区别/","permalink":"https://zhukejin.com/2019/%E5%85%B3%E4%BA%8E-Rxjs-%E4%B8%AD-Reduce-Scan-%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"官方手册：https://cn.rx.js.org/class/es6/Observable.js~Observable.html#instance-method-scan 关于Scan 官方描述的比较抽象实质上和 Reduce 非常相像，熟悉 Array.reduce 的同学对Rxjs 中的Reduce 操作符想必也不陌生。 而 Scan 和 Reduce 在 归并 的原理上是相同的，唯一不同的 Emit 的时机。 Scan apply a function to each item emitted by an Observable, sequentially, and &#x3D;&#x3D;emit each successive value&#x3D;&#x3D; Ex: 12345678910// 依次递加元素of(1, 2, 3).pipe(scan((acc, curr) =&gt; curr + acc)).subscribe(val =&gt; &#123; console.log(&#x27;res: &#x27; + val)&#125;)// 输出结果res: 1res: 3res: 6","text":"官方手册：https://cn.rx.js.org/class/es6/Observable.js~Observable.html#instance-method-scan 关于Scan 官方描述的比较抽象实质上和 Reduce 非常相像，熟悉 Array.reduce 的同学对Rxjs 中的Reduce 操作符想必也不陌生。 而 Scan 和 Reduce 在 归并 的原理上是相同的，唯一不同的 Emit 的时机。 Scan apply a function to each item emitted by an Observable, sequentially, and &#x3D;&#x3D;emit each successive value&#x3D;&#x3D; Ex: 12345678910// 依次递加元素of(1, 2, 3).pipe(scan((acc, curr) =&gt; curr + acc)).subscribe(val =&gt; &#123; console.log(&#x27;res: &#x27; + val)&#125;)// 输出结果res: 1res: 3res: 6 也就是在每次 scan 归并后，立即触发 subscribe. reduce apply a function to each item emitted by an Observable, sequentially, and &#x3D;&#x3D;emit the final value&#x3D;&#x3D; Ex: 12345678// 依次递加元素of(1, 2, 3).pipe(reduce((acc, curr) =&gt; curr + acc)).subscribe(val =&gt; &#123; console.log(&#x27;res: &#x27; + val)&#125;)// 输出结果res: 6 也就是在每次 reduce 归并后，没有立即触发 subscribe，而是在最终结束归并后，才发出消息。 参考资料： https://rxjs-cn.github.io/learn-rxjs-operators/operators/transformation/scan.htmlhttps://stackoverflow.com/questions/45350806/whats-difference-between-reduce-and-scan","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhukejin.com/categories/JavaScript/"}],"tags":[{"name":"RxJS","slug":"RxJS","permalink":"https://zhukejin.com/tags/RxJS/"}]},{"title":"同时配置Github & GitLab","slug":"同时配置Github、GitLab","date":"un66fin66","updated":"un00fin00","comments":true,"path":"2018/同时配置Github、GitLab/","permalink":"https://zhukejin.com/2018/%E5%90%8C%E6%97%B6%E9%85%8D%E7%BD%AEGithub%E3%80%81GitLab/","excerpt":"在一台电脑上同时配置 Github 和 GitLab 公司Git 仓库托管在 GitLab 上，而我个人研究的小玩意在GitHub 上，为了能同时满足双线 update 需求，决定通过Config 分离两个账号。","text":"在一台电脑上同时配置 Github 和 GitLab 公司Git 仓库托管在 GitLab 上，而我个人研究的小玩意在GitHub 上，为了能同时满足双线 update 需求，决定通过Config 分离两个账号。 ** 1. 生成单独的 SSH Key ** //GitLab 生成方法一样， 或者默认先生成Gitlab， 以公司账户为主 ssh-keygen -t rsa -f ~/.ssh/id_rsa_github -C &quot;zhukejin@msn.com&quot; ** 2. 添加 SSH Key 到Github ** Github-&gt; Setting -&gt; SSH and GPG Keys -&gt; 右上角 New SSH Key cat ~&#x2F;.ssh&#x2F;id_rsa_github.pub 将其中的 Public Key 添加到 Github 中 ** 3. 添加 Config ** vim ~&#x2F;.ssh&#x2F;config 加入以下配置 # gitlab Host gitlab.com HostName gitlab.com PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa # github Host github.com HostName github.com PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa_github ** 4. 测试 ** ssh -T git@github.com 如果出现: Hi zhukejin1223! You&#39;ve successfully authenticated, but GitHub does not provide shell access. 这样.. 就说明github 副Key 配置成功了，然后再去试一下 GitLab 能不能提交了…","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhukejin.com/categories/JavaScript/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://zhukejin.com/tags/Git/"}]},{"title":"位运算符~的hack用法","slug":"位运算符-的hack用法","date":"un00fin00","updated":"un00fin00","comments":true,"path":"2018/位运算符-的hack用法/","permalink":"https://zhukejin.com/2018/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6-%E7%9A%84hack%E7%94%A8%E6%B3%95/","excerpt":"如何用更少的代码判断数组中是否存在某值？ 123const arr = [1,2,3,4,5,6,7];~arr.indexOf(2); // true","text":"如何用更少的代码判断数组中是否存在某值？ 123const arr = [1,2,3,4,5,6,7];~arr.indexOf(2); // true 等同于 1arr.indexOf(2) !== -1 因为~（位异或）对任何数字相当于-(a + 1) ES6 的新方法 123const arr = [1,2,3,4,5,6,7];arr.includes(2); // true","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhukejin.com/categories/JavaScript/"}],"tags":[]},{"title":"函数去抖（debounce）与函数节流 （throttle）","slug":"debounce-throttle","date":"un33fin33","updated":"un00fin00","comments":true,"path":"2018/debounce-throttle/","permalink":"https://zhukejin.com/2018/debounce-throttle/","excerpt":"场景一 王者荣耀的普攻阈值是怎么实现的？ 射击游戏里的攻击速度是怎么限制的？ 怎样计算滚动条滚动位置，最多50ms 计算一次？","text":"场景一 王者荣耀的普攻阈值是怎么实现的？ 射击游戏里的攻击速度是怎么限制的？ 怎样计算滚动条滚动位置，最多50ms 计算一次？ 概念函数节流 调节强制执行一段时间内可以调用函数的最大次数，如“每100毫秒最多执行一次”。在正常情况下，我们可以在10秒钟内调用此函数1000次。如果每100毫秒将其限制为仅一次，则最多只能执行该功能100次。 函数节流的核心是，让一个函数不要执行得太频繁，减少一些过快的调用来节流。 例如上述场景中，游戏里的攻速限制，就是使用的函数节流的手段。 场景二 即时搜索的搜索框中，如何控制只在用户输入完成后触发ajax ？ 函数去抖 强制一个函数在一段时间内只被调用一次。如“一个函数100毫秒内只执行一次”。也许一个函数在很集中的时间内被调用1000次，超过3秒，然后停止调用。如果我们在100毫秒内将其去抖动，该函数将仅启动一次3.1秒。函数去抖就是对于一定时间段的连续的函数调用，只让其执行一次。 异同 相同点：都是为了处理性能问题而限制 UI 操作 就像一窝蜂的人去排队看演出，队伍很乱，看门的老大爷每隔1秒，让进一个人，这个叫throttle，如果来了这一窝蜂的人，老大爷一次演出只让进一个人，下次演出才让下一个人进，这个就叫debounce。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhukejin.com/categories/JavaScript/"}],"tags":[]},{"title":"Angular2-ChangeDetector","slug":"Angular2-ChangeDetector","date":"un55fin55","updated":"un00fin00","comments":true,"path":"2018/Angular2-ChangeDetector/","permalink":"https://zhukejin.com/2018/Angular2-ChangeDetector/","excerpt":"Angular 6 数据发生变化视图不更新场景 &#x2F;&#x2F; 首先将任务添加至异步队列setTimeout(() &#x3D;&gt; { &#x2F;&#x2F; 异步队列中加 promise new Promise()… }, 0) 此时 resolve 方法中修改数据，发现视图没有更新。 原因","text":"Angular 6 数据发生变化视图不更新场景 &#x2F;&#x2F; 首先将任务添加至异步队列setTimeout(() &#x3D;&gt; { &#x2F;&#x2F; 异步队列中加 promise new Promise()… }, 0) 此时 resolve 方法中修改数据，发现视图没有更新。 原因 猜测可能是因为异步队列 + 异步 Request 请求脱离了 ngZone 的执行范围 解决方法 注入 CDK 123456constructor( private cdf: ChangeDetectorRef) &#123; &#125;......this.cdf.markForCheck(); //它能标记整颗组件树的目录直到下一次变化监测的执行this.cdf.detectChanges(); // 主要是这句，对当前组件及其子组件都运行检测。即使组件是否检测状态是关闭的，也会运行检测。 数据修改后调用 detectChanges(); 强制触发标记处的数据更新 detectChanges 有点类似 angular1 中的 $apply 缺点 在设置了 detectChanges() 后， 所有的数据变化都需要手动触发。 参考资料 https://www.jianshu.com/p/09c9d937920b","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhukejin.com/categories/JavaScript/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"https://zhukejin.com/tags/Angular/"}]},{"title":"arts-20180914-合并两个有序数组","slug":"arts-20180914","date":"un55fin55","updated":"un00fin00","comments":true,"path":"2018/arts-20180914/","permalink":"https://zhukejin.com/2018/arts-20180914/","excerpt":"Algorithm https://leetcode-cn.com/problems/merge-sorted-array/description/ 题目给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。 说明: 初始化 nums1 和 nums2 的元素数量分别为 m 和 n。 你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。","text":"Algorithm https://leetcode-cn.com/problems/merge-sorted-array/description/ 题目给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。 说明: 初始化 nums1 和 nums2 的元素数量分别为 m 和 n。 你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。 示例: 12345**输入**:nums1 = [1,2,3,0,0,0], m = 3nums2 = [2,5,6], n = 3**输出**: [1,2,2,3,5,6] 思考 直接合并 我的解答： 1234567891011121314151617/** * @param &#123;number[]&#125; nums1 * @param &#123;number&#125; m * @param &#123;number[]&#125; nums2 * @param &#123;number&#125; n * @return &#123;void&#125; Do not return anything, modify nums1 in-place instead. */var merge = function (nums1, m, nums2, n) &#123; nums1.splice(m); nums2.splice(n); nums1.push(...nums2); nums1.sort((a, b) =&gt; a - b);&#125;; Share &amp;&amp; Review关于Google Flutter，你到底了解多少？ Tips 自驱力很重要， 特别是当公司业务趋向简单、繁琐与重复的体力劳动之时。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhukejin.com/categories/JavaScript/"}],"tags":[{"name":"ARTS","slug":"ARTS","permalink":"https://zhukejin.com/tags/ARTS/"}]},{"title":"arts-20180910","slug":"arts-20180910","date":"un11fin11","updated":"un00fin00","comments":true,"path":"2018/arts-20180910/","permalink":"https://zhukejin.com/2018/arts-20180910/","excerpt":"Algorithm 本次题目由同事提供。 题目已知字符串 str=&#39;abcdefg&#39;，求一个方法 unFlattenDeep(str) , 可以返回一个对象 Obj ，使 Obj.a.b.c.d.e.f.g &#x3D; 1","text":"Algorithm 本次题目由同事提供。 题目已知字符串 str=&#39;abcdefg&#39;，求一个方法 unFlattenDeep(str) , 可以返回一个对象 Obj ，使 Obj.a.b.c.d.e.f.g &#x3D; 1 思考 最暴力的方法，递归。 聪明点的方法，ES5 的 Array Reduce 方法。 我的解答： 12345678910111213141516171819202122232425262728293031/** * @param &#123;string&#125; Str * @return &#123;Object&#125; Obj * 使用 递归来解决 */var unFlattenDeep = function(Str) &#123; var i = 0; var Obj = &#123;&#125;; var arr = Str.split(&#x27;&#x27;); function setFirstChild(o, key) &#123; // 查找完毕 if (i === arr.length - 1) &#123; o[key] = 1; return; &#125; else &#123; o[key] = &#123;&#125;; &#125; setFirstChild(o[key], arr[++i]); &#125; setFirstChild(Obj, arr[i]); return Obj;&#125;;var Str = &#x27;abcdefg&#x27;;console.log(unFlattenDeep(Str)) 1234567891011/** * 使用 Reduce 来解决 */function unFlattenDeep(arr, obj) &#123; return arr.reduce((o, k, i, a) =&gt; (o[k] = i === a.length - 1 ? 1 : &#123;&#125;), obj) &amp;&amp; obj;&#125;let res = unFlattenDeep(&#x27;abcd&#x27;.split(&#x27;&#x27;), &#123;&#125;);console.log(res.a.b.c.d) 然后，同事说出了他的解法 Json 反序列化法只需要把字符串处理成JSON 格式， 然后解析字符串即可。(喷血) Share &amp;&amp; Review想学机器学习只能再学一遍Python、Java、C++ ？前端福利来了 从TensorFlow.js入手了解机器学习https://mp.weixin.qq.com/s/gpMTMaCKQRJu13F-QK4NCA Tips 本次没有。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhukejin.com/categories/JavaScript/"}],"tags":[{"name":"ARTS","slug":"ARTS","permalink":"https://zhukejin.com/tags/ARTS/"}]},{"title":"arts-20180810","slug":"arts-20180810","date":"un55fin55","updated":"un00fin00","comments":true,"path":"2018/arts-20180810/","permalink":"https://zhukejin.com/2018/arts-20180810/","excerpt":"Algorithm leetcode 链接： https://leetcode-cn.com/problems/two-sum/ 题目：给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。 你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。","text":"Algorithm leetcode 链接： https://leetcode-cn.com/problems/two-sum/ 题目：给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。 你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。 示例: 1234给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 我的解答： 12345678910111213141516/** * @param &#123;string&#125; s * @return &#123;number&#125; * 使用 es6 哈希表来解决 */var twoSum = function(nums, target) &#123; let myMap = new Map(); for (let i = 0; i &lt; nums.length; i++) &#123; let complement = target - nums[i]; if (myMap.has(complement)) &#123; return [myMap.get(complement), i]; &#125; myMap.set(nums[i], i); &#125;&#125;; Share &amp;&amp; Review你以为 CSS 中的 display 只有 block&#x2F;inline&#x2F;none 吗？ display 大全：https://developer.mozilla.org/zh-CN/docs/Web/CSS/display Tips 宁与骐骥亢轭乎，将随驽马之迹乎？宁与黄鹄比翼乎，将与鸡鹜争食乎？世溷浊而不清：蝉翼为重，千钧为轻；黄钟毁弃，瓦釜雷鸣；谗人高张，贤士无名。** —- 《卜居》**","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhukejin.com/categories/JavaScript/"}],"tags":[{"name":"ARTS","slug":"ARTS","permalink":"https://zhukejin.com/tags/ARTS/"}]},{"title":"arts-20180724","slug":"arts-20180724","date":"un22fin22","updated":"un00fin00","comments":true,"path":"2018/arts-20180724/","permalink":"https://zhukejin.com/2018/arts-20180724/","excerpt":"Algorithm leetcode 链接： https://leetcode-cn.com/problems/length-of-last-word/description/ 题目：给定一个仅包含大小写字母和空格 ‘ ‘ 的字符串，返回其最后一个单词的长度。 如果不存在最后一个单词，请返回 0 。 说明：一个单词是指由字母组成，但不包含任何空格的字符串。","text":"Algorithm leetcode 链接： https://leetcode-cn.com/problems/length-of-last-word/description/ 题目：给定一个仅包含大小写字母和空格 ‘ ‘ 的字符串，返回其最后一个单词的长度。 如果不存在最后一个单词，请返回 0 。 说明：一个单词是指由字母组成，但不包含任何空格的字符串。 示例: 12输入: &quot;Hello World&quot;输出: 5 我的解答： 12345678/** * @param &#123;string&#125; s * @return &#123;number&#125; */const lengthOfLastWord = function(s) &#123; let arr = s.trim().split(&#x27; &#x27;); return arr[arr.length - 1].length;&#125;; Share &amp;&amp; Review大数据时代能为前端开发者带来什么？ Guess.js 的目标是最大限度地减少 bundle 布局配置，实现数据驱动，并使之更加准确。你应该延迟加载你所有的路径，Guess.js 会找出哪些 bundle 可以结合在一起，使用什么预取机制（pre-fetching mechanism），而且这些动作都能在 5 分钟内完成。 https://github.com/guess-js Tips 遍阅人情，始识疏狂之足贵；备尝世味，方知淡泊之为真** —- 明 · 洪应明 ·《菜根谭》**","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhukejin.com/categories/JavaScript/"}],"tags":[{"name":"ARTS","slug":"ARTS","permalink":"https://zhukejin.com/tags/ARTS/"}]},{"title":"寻找连续最长的递增序列","slug":"longest-continuous-increasing-subsequence","date":"un33fin33","updated":"un00fin00","comments":true,"path":"2018/longest-continuous-increasing-subsequence/","permalink":"https://zhukejin.com/2018/longest-continuous-increasing-subsequence/","excerpt":"Leetcode 系列 原题： https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/description/ 题目给定一个未经排序的整数数组，找到最长且连续的的递增序列。","text":"Leetcode 系列 原题： https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/description/ 题目给定一个未经排序的整数数组，找到最长且连续的的递增序列。 示例 1: 输入: [1,3,5,4,7] 输出: 3 解释: 最长连续递增序列是 [1,3,5], 长度为3。 尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为5和7在原数组里被4隔开。 123**示例 2:** 输入: [2,2,2,2,2] 输出: 1 解释: 最长连续递增序列是 [2], 长度为1。 注意：数组长度不会超过10000。 12345678910111213141516171819202122232425262728293031323334353637383940414243##### 解答```JavaScript/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */const findLengthOfLCIS = function (nums) &#123; if (nums.length === 0) return 0; let numArr = []; let number = 1; nums.forEach((v, k) =&gt; &#123; const p = v, n = nums[k + 1]; // 当 n &gt; p 的时候，证明是连续递增状态 if (n &gt; p) &#123; number++; &#125; else if (n &lt; p) &#123; // 递增结束，同时上次计数结果入栈, 重置计数器 numArr.push(number); number = 1; &#125; &#125;); // 尾数入栈 numArr.push(number); // 抛出最大值 return Math.max.apply(null, numArr)&#125;;let arr = [1,2,3,12,2,3,5,1,3,3,5,5,6,12];const res = findLengthOfLCIS(arr);console.log(res);","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhukejin.com/categories/JavaScript/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://zhukejin.com/tags/Algorithm/"}]},{"title":"chrome-console","slug":"chrome-console","date":"un22fin22","updated":"un00fin00","comments":true,"path":"2018/chrome-console/","permalink":"https://zhukejin.com/2018/chrome-console/","excerpt":"command + shift + j 打开控制台 一般输出 console.log() 普通打印 console.info() 一般信息 console.warn() 警告提示 console.error() 错误提示 console.debug() 等于 log","text":"command + shift + j 打开控制台 一般输出 console.log() 普通打印 console.info() 一般信息 console.warn() 警告提示 console.error() 错误提示 console.debug() 等于 log 大家可能不知道的，console 可以使用 printf 风格的占位符目前支持字符（%s）、整数（%d或%i）、浮点数（%f）、格式化自身(%c)、格式化 DOM对象(%o) 、 格式化 JavaScript 对象 (%O)。 console.group()console.groupEnd()分组打印内容 console.groupCollapsed()分组打印内容， 默认折叠 console.table()可以直接把一个 [] 类型数组，输出成表格 console.trace()追溯式打印, 我们代码中的 1console.log(this.xxx, 13123123) 以后就可以换成 1console.trace(this.xxx) 了 console.dir()打印级联内容, 类似上面的 console 1console.dir(document.body) console.dirxml()打印级联内容，并以 xml 格式解析 1console.dirxml(document.body) console.assert() 断言它会在传入的第一个参数为 false 的时候， 抛出第二个参数。举个例子，为了防止日常开发中的日志信息误上生产环境后产生的一些问题， 可以设置全局 debug 常量： 12345const appConfig = &#123; debug: true&#125;console.assert(!debug, &#x27;错误信息&#x27;) console.clear() 清空控制台清空控制台信息，同直接执行 clear() 或者按 cmd + k， 不同的是它可以在代码中调用 console.context()返回 console 对象的内容： 12const myc = console.context();myc.log(123) 目前想不到实际用处 console.count() 计数可以记录一个函数或者一段代码重复执行了多少次，每执行一次，就会自动增加1 1Array(3).fill(0).forEach(v =&gt; console.count(&#x27;执行次数：&#x27;)) 性能分析console.time()console.timeEnd() console.memory性能分析工具，可以用来查看当前堆栈的使用情况它是 console 的一个属性，不是一个方法。 console.profile()console.profileEnd()可以查看 CPU 使用相关的信息、代码执行具体过程。鸡肋， 可以通过UI 实现。 其他技巧选择元素$()返回满足指定CSS规则的第一个元素，此方法为document.querySelector()的简化 $$()返回满足指定CSS规则的所有元素，此方法为querySelectorAll()的简化。 XPathXPath即为XML路径语言（XML Path Language），它是一种用来确定XML文档中某部分位置的语言。 xPath 语法：http://www.w3school.com.cn/xpath/ 例子: $_访问最近的控制台结果，如： inspect可以直接在命令行中审查元素 inspect($0) copy直接复制到系统粘贴板 1copy(document.body) keys &amp; values同 Object.keys 、Object、values monitor &amp; unmonitor监控一个函数的调用，打印出这个函数的具体调用信息，如果想知道一个函数在哪里被调用了，一共调用几次的时候， 很有用。 monitorEvents监控事件，ex: 1monitorEvents(document.body, &quot;click&quot;); 参考文章： https://developers.google.com/web/tools/chrome-devtools/console/http://www.cnblogs.com/Wayou/p/chrome-console-tips-and-tricks.html","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhukejin.com/categories/JavaScript/"}],"tags":[]},{"title":"久别离","slug":"久别离","date":"un66fin66","updated":"un00fin00","comments":true,"path":"2018/久别离/","permalink":"https://zhukejin.com/2018/%E4%B9%85%E5%88%AB%E7%A6%BB/","excerpt":"","text":"久别离，辞家百里无逢期。久别离，叹兮窗台花正迷。正值子夜白鬼行，恰闻空空腹中饥。孑身执笔谋他法，左右无事赋诗与。久别离，乏味索然吟声低。书有相思字，举目望江西。一年春又发，筑巢燕衔泥。久别离，四下唯我独凄凄。","categories":[{"name":"Verses","slug":"Verses","permalink":"https://zhukejin.com/categories/Verses/"}],"tags":[]},{"title":"OverFlow 导致页面白屏","slug":"overFlow-made-white-screen","date":"un44fin44","updated":"un00fin00","comments":true,"path":"2018/overFlow-made-white-screen/","permalink":"https://zhukejin.com/2018/overFlow-made-white-screen/","excerpt":"因可能随时修改，所以转载请注明来源，以便读者追本朔源本文地址: https://zhukejin.com/overFlow-made-white-screen 现象 系统：iOS 11 + Safari 框架：React + redux + react-router + Ant Design Mobile 复现过程在组件中使用了 antd 的 picker （time picker、date picker、select picker等等任意picker）后，点击某链接进入其他组件，会导致页面白屏。 该问题只出现在ios 中， PC 端 chrome 模拟正常。 使用 XCode 安装的ios 模拟器也会出现这个问题。","text":"因可能随时修改，所以转载请注明来源，以便读者追本朔源本文地址: https://zhukejin.com/overFlow-made-white-screen 现象 系统：iOS 11 + Safari 框架：React + redux + react-router + Ant Design Mobile 复现过程在组件中使用了 antd 的 picker （time picker、date picker、select picker等等任意picker）后，点击某链接进入其他组件，会导致页面白屏。 该问题只出现在ios 中， PC 端 chrome 模拟正常。 使用 XCode 安装的ios 模拟器也会出现这个问题。 探索通过 Safari debug 发现 白屏后元素还在，css 属性也都很正常 react 的 render 方法也执行了，didMount 也正常执行 Picker 曾给 body 添加了一个 overflow: hidden; 的属性，但是在关闭的是马上又删除了。此举是防止picker 打开后body 滚动的问题。 在body 上任意设置 overflow 属性或者 display 属性，内容立即就显示出来了。 猜测由于之前在 firefox PC 上遇到过类似的问题，所以猜测是浏览器渲染的问题。 可能 浏览器在执行某一步的时候 跳过&#x2F;卡住 等等，导致浏览器没有正确的渲染DOM。具体原因还有待探索 解决方案123456789// todo 暂时可以解决其他组件打开picker 后首页不渲染的问题，但是需要寻找真正原因componentDidMount() &#123; delay(() =&gt; &#123; window.document.body.style.overflowY = &#x27;hidden&#x27;; delay(() =&gt; &#123; window.document.body.style.overflowY = &#x27;auto&#x27;; &#125;, 0) &#125;, 0);&#125;","categories":[{"name":"CSS","slug":"CSS","permalink":"https://zhukejin.com/categories/CSS/"}],"tags":[]},{"title":"戊戌杂诗-其三","slug":"戊戌杂诗-其三","date":"un22fin22","updated":"un00fin00","comments":true,"path":"2018/戊戌杂诗-其三/","permalink":"https://zhukejin.com/2018/%E6%88%8A%E6%88%8C%E6%9D%82%E8%AF%97-%E5%85%B6%E4%B8%89/","excerpt":"","text":"正气为体瞳作门神台空灵镜无尘不似凡俗千种色唯有寒江照月心","categories":[{"name":"Verses","slug":"Verses","permalink":"https://zhukejin.com/categories/Verses/"}],"tags":[]},{"title":"再谈 Blog 的优化历程","slug":"wordPress2hexo","date":"un55fin55","updated":"un00fin00","comments":true,"path":"2018/wordPress2hexo/","permalink":"https://zhukejin.com/2018/wordPress2hexo/","excerpt":"大概在 2014 年的时候，买了一台香港的VPS，开始写博客，那时候使用的是最简单最传统的 nginx + php + wordpress 博客。 最近薅（hao, 一声）了腾讯的羊毛，360 大洋搞了 7 年的低配云服务器，折腾着迁移博客，顺便做了一点优化。 先对比一下之前 香港主机的 WordPress 和 目前的 腾讯云 hexo WordPress: Hexo: 从 WordPress 到 Hexo一直到2017年，才再也无法忍受 WordPress 管理起来的繁琐，开始使用 hexo + github.io 来写博客。 WordPress 在每次访问的时候，都会进行大量的数据库查询，而关系数据库查询也是非常消耗资源的。 相比 Wp，Hexo 的优势就体现出来了，它是本地的 Markdown 文件编译成静态文件，也就是说省去了 PHP –&gt; 数据库查询 这一个步骤。无论是对服务器的负荷还是对网络的负荷都远远低于 WP。 关于 Hexo，这里是官网 https://hexo.io/，使用起来非常简单。另外尽量使用一些简洁的主题我使用的是： https://github.com/litten/hexo-theme-yilia","text":"大概在 2014 年的时候，买了一台香港的VPS，开始写博客，那时候使用的是最简单最传统的 nginx + php + wordpress 博客。 最近薅（hao, 一声）了腾讯的羊毛，360 大洋搞了 7 年的低配云服务器，折腾着迁移博客，顺便做了一点优化。 先对比一下之前 香港主机的 WordPress 和 目前的 腾讯云 hexo WordPress: Hexo: 从 WordPress 到 Hexo一直到2017年，才再也无法忍受 WordPress 管理起来的繁琐，开始使用 hexo + github.io 来写博客。 WordPress 在每次访问的时候，都会进行大量的数据库查询，而关系数据库查询也是非常消耗资源的。 相比 Wp，Hexo 的优势就体现出来了，它是本地的 Markdown 文件编译成静态文件，也就是说省去了 PHP –&gt; 数据库查询 这一个步骤。无论是对服务器的负荷还是对网络的负荷都远远低于 WP。 关于 Hexo，这里是官网 https://hexo.io/，使用起来非常简单。另外尽量使用一些简洁的主题我使用的是： https://github.com/litten/hexo-theme-yilia 从香港主机到 GitHub, 再到 Coding 双线解析考虑到博客的健壮性和部署的便捷性，我把博客部署目标选择到 Github 的个人主页。 参见此处：https://pages.github.com/ 新建一个同名项目，如 zhukejin.github.io, 保持私有。此项目即为 github 个人主页的资源。 但是因为一些众所周知的原因，国内用户访问 github 偶尔不稳定，这时候轮到 https://coding.net/v1/pages/ 登场了，coding 的服务可以理解为国内版的 github，有着跟 github 几乎一模一样的使用、部署方式。 Hexo 自带了git 方式部署，所以只需要简单配置即可： 为了国外用户继续访问速度更快的 github，可以使用双线解析： 将海外 IP 解析到 pages.github.io, 将国内 IP 解析到 pages.coding.me。 如图使用的是阿里云的 DNS 解析： 上图是我现在的解析，不过已经干掉了 coding.me， 而是指向了我自己的腾讯云 IP，但是海外线路依旧是 Github.io 部署腾讯云在前几天薅了腾讯的羊毛后，想同时把 hexo 三线部署到自己的服务器上，怎么搞？ 在服务上安装一个 git，然后作为初始化仓库，往里面push 东西。 在服务器上安装 ftp， 然后通过 hexo 提供的 ftp 方式部署。 然鹅俺比较懒，也不想装 git 也不想装 ftp， 于是自己写了个简单的脚本： 12345678910111213#!/bin/bashcd ../blogzip -q -r blog.zip ./publicscp blog.zip tencentyun:/home/webssh tencentyun &lt;&lt; eeooffcd /home/webrm -rf blog.bak.zipzip -q -r blog.bak.zip blogunzip -o blog.ziprm -rf blog.zip blogmv public blogeeooffecho push success! 懒人思路:直接用 scp 把 hexo 编译的 public 文件夹打包上传到服务器，然后在服务器解压即可 TAT.. 开启 Nginx 的 GZIPGULP 双重压缩静态资源css sprites中文可以称之为 “CSS雪碧图”，这种方法就是把一些零碎的图片、图标集中在一张图上面，使用的时候通过 Position 来显示对应的位置。 和js、Css多文件整合一样，这样做的好处就是可以减少大量的 HTTP 请求，要知道每次 HTTP 请求都是非常消耗时间的, CDN 接入CDN 厂商在全国各地都有机房，方便访客以最快的速度访问最近的节点，这点显然是比我们自己的单点服务器优势要大的多。 比如在 Hexo 中使用七牛的图床、使用Bootcdn 的Jquery、Rest.css 这样的资源。 预加载在一些比较大的项目中，如果使用了trunk 拆解后，静态资源依然很大的，可以考虑预加载的思路，常见的预加载有两种方法： 当用户触发Hover 的时候，预先加载用户 “有点击趋向” 的页面，常见绑定在菜单、导航中。在存在加载即生效的资源下，这种方式风险比较大，要谨慎使用。 而在手机页面中，click 事件本身便有300ms 的延迟，完全可以在这段时间内做预加载。 这里要提到的是一个库 InstantClick 官网：http://instantclick.io/ InstantClick 封装了这两种方式，并且提供了白名单、黑名单策略，防止敏感资源的误加载。 Nginx 通知浏览器缓存资源考虑到图片这些资源， 基本情况是不会变的，可以在 Nginx 中做如下配置，缓存一个月。 123location ~* \\.(jpg|jpeg|png|gif|ico|css|js)$ &#123; expires 1M;&#125; 但是需要注意一点，如果开启了缓存， 最好在更新版本时加上hash值、版本号这样的标识码，以防止新资源无法加载。 关于升级 HTTPS 带来的性能损耗","categories":[{"name":"Other","slug":"Other","permalink":"https://zhukejin.com/categories/Other/"}],"tags":[]},{"title":"关于 overflow auto 在ff 中失效的问题","slug":"overflow-ff","date":"un44fin44","updated":"un00fin00","comments":true,"path":"2018/overflow-ff/","permalink":"https://zhukejin.com/2018/overflow-ff/","excerpt":"","text":"踩过的坑和走过的路 在Table中设置了一个 scroll, 为了没美观， 便加了个 overflow： auto， Chrome 中正常， FireFox 会导致 scroll 失效。 解决办法：在所有的td 中限制一下宽度，ex： 1&lt;td style=&quot;min-width: 100px; max-width: 100px;&quot;&gt;","categories":[{"name":"CSS","slug":"CSS","permalink":"https://zhukejin.com/categories/CSS/"}],"tags":[]},{"title":"hexo 访问 tags 404的问题","slug":"tags-404","date":"un11fin11","updated":"un00fin00","comments":true,"path":"2017/tags-404/","permalink":"https://zhukejin.com/2017/tags-404/","excerpt":"关于 hexo + yillia 主题部署后访问 Tags 404 的问题 问题场景 github page + hexo + yillia + 自定义域名 在本地服务(hexo s) 中, localhost:4000/tags/JavaScript/ 访问正常 在部署到服务器后， zhukejin.com/tags/JavaScript/ 显示404","text":"关于 hexo + yillia 主题部署后访问 Tags 404 的问题 问题场景 github page + hexo + yillia + 自定义域名 在本地服务(hexo s) 中, localhost:4000/tags/JavaScript/ 访问正常 在部署到服务器后， zhukejin.com/tags/JavaScript/ 显示404 原因怀疑是 hexo 的bug，在编译后，public &gt; tags 下的 JavaScript 标签中的 S 被编译成了小写， 于 hexo s 时不一致导致。 解决办法将 theme&#x2F;yillia&#x2F;_config.yml 中的对应的快捷标签访问链接修改为 &#x2F;tags&#x2F;Javascript&#x2F; 即可 等待后续hexo 更新。 更新在 yillia 的最新版本中，此问题已经被修复。 2018年03月08日14:43:02 *","categories":[{"name":"Other","slug":"Other","permalink":"https://zhukejin.com/categories/Other/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://zhukejin.com/tags/hexo/"}]},{"title":"登华山-莲花峰","slug":"登华山-莲花峰","date":"un22fin22","updated":"un00fin00","comments":true,"path":"2017/登华山-莲花峰/","permalink":"https://zhukejin.com/2017/%E7%99%BB%E5%8D%8E%E5%B1%B1-%E8%8E%B2%E8%8A%B1%E5%B3%B0/","excerpt":"国庆前夕登华山所作 西上莲花峰，百里辞人城。云台披仙雾，周野触鸿蒙。龙岭皆遁客，摩肩翠云宫。遑遑来之去，何以摄太清。","text":"国庆前夕登华山所作 西上莲花峰，百里辞人城。云台披仙雾，周野触鸿蒙。龙岭皆遁客，摩肩翠云宫。遑遑来之去，何以摄太清。","categories":[{"name":"Verses","slug":"Verses","permalink":"https://zhukejin.com/categories/Verses/"}],"tags":[]},{"title":"Sass 笔记","slug":"scss-note","date":"un44fin44","updated":"un00fin00","comments":true,"path":"2017/scss-note/","permalink":"https://zhukejin.com/2017/scss-note/","excerpt":"很久没有写CSS，最近写Css 的时候发现很多 Sass 语法忘记了，本着好记性不如烂笔头的原则，开一篇记录一下常用的 Sass 语法为方便读者追本索源，转载请保留本文地址 变量变量使用 $ 来声明，ex: 12345$smallFont: 12px;$normalFont: 14px;$largeFont: 16px;$baseColor: #E86295;","text":"很久没有写CSS，最近写Css 的时候发现很多 Sass 语法忘记了，本着好记性不如烂笔头的原则，开一篇记录一下常用的 Sass 语法为方便读者追本索源，转载请保留本文地址 变量变量使用 $ 来声明，ex: 12345$smallFont: 12px;$normalFont: 14px;$largeFont: 16px;$baseColor: #E86295; 使用的时候: 12color: $baseColor;font-size: $smallFont; 假如变量需要拼接，则需要使用 #&#123;$baseColor&#125; 这样的语法来拼接，如： 12$calc: 306 + 32;height: calc(100vh - #&#123;$calc&#125;); 方法方法、关键字指令使用 @ 来标记， ex: 123@function mySize($size) &#123; @return $size + 24 + px;&#125; 使用的时候直接 1font-size: mySize(12); 循环使用 each 关键字: 12345@each $type in center, left, right &#123; .text-#&#123;$type&#125; &#123; text-align: $type; &#125;&#125; 逻辑判断使用 if 关键字: 1234567@function mySize($size) &#123; @if $size &lt; 14 &#123; @return $size + px; &#125; @else &#123; @return $size + 24 + px; &#125;&#125; 混淆混淆的作用是分离代码块, 在 scss 中导入 混淆即可引入代码块 12345@mixin button() &#123; font-size: 14px; text-align: center; padding: 10px 20px;&#125; 使用的时候： 12345.my-btn &#123; ... @include button(); ...&#125;","categories":[{"name":"CSS","slug":"CSS","permalink":"https://zhukejin.com/categories/CSS/"}],"tags":[{"name":"SASS","slug":"SASS","permalink":"https://zhukejin.com/tags/SASS/"}]},{"title":"客从远方来","slug":"客从远方来","date":"un66fin66","updated":"un00fin00","comments":true,"path":"2017/客从远方来/","permalink":"https://zhukejin.com/2017/%E5%AE%A2%E4%BB%8E%E8%BF%9C%E6%96%B9%E6%9D%A5/","excerpt":"","text":"春节前后叙事诗，有人问为什么最近喜欢写五言，因为我懒。 正文： 客从远方来，邀我至林间。云之苍苍色，莽莽走大川。我既随之往，泠然冬雪寒。风光多瑰丽，去处皆名山。九曲碧波路，青峰云海间。银妆裹碎玉，十里分仙凡。乾坤把芙蓉，馈之造福泉。凝露蒸琼玉，沐此起芳年。予人曰春华，还君兮秋兰。身重着枷锁，足浅落方圆。值君再来时，我恐无以还。","categories":[{"name":"Verses","slug":"Verses","permalink":"https://zhukejin.com/categories/Verses/"}],"tags":[]},{"title":"使用 Range 选中Dom并进行复制","slug":"select-and-copy-dom","date":"un44fin44","updated":"un00fin00","comments":true,"path":"2016/select-and-copy-dom/","permalink":"https://zhukejin.com/2016/select-and-copy-dom/","excerpt":"本文为作者原创，随时可能修改，为保证准确性，转载请保留本文地址以便读者追本朔源。 起因：JavaScript 选中内容复制的时候，使用 execCommand(&#39;selectAll&#39;) 是无法选中普通DOM，只能在 “编辑区” 选择.参见 https://developer.mozilla.org/zh-CN/docs/Web/API/Document/execCommand","text":"本文为作者原创，随时可能修改，为保证准确性，转载请保留本文地址以便读者追本朔源。 起因：JavaScript 选中内容复制的时候，使用 execCommand(&#39;selectAll&#39;) 是无法选中普通DOM，只能在 “编辑区” 选择.参见 https://developer.mozilla.org/zh-CN/docs/Web/API/Document/execCommand 方案：为了简单，不去舍本求末的弄个隐藏域或者 disabled 的文本框，现在创建 Range 来选择。 1.创建 Range 1const range = document.createRange(); Range表示包含节点和部分文本节点的文档片段。Range可以用 Document 对象的 createRange方法创建，也可以用Selection对象的getRangeAt方法取得。 另外，可以通过构造函数 Range() 来获得一个 Range 。 2.选择要复制的元素 1const EL = this.el.nativeElement.querySelector(&#x27;.code&#x27;); 3.选择Node 1const selectEl = range.selectNode(EL); Range.selectNode()设定一个包含节点和节点内容的 Range 4.将此Node 添加到Range 对象中 1(&lt;any&gt;window).getSelection(selectEl).addRange(range); 5.执行系统复制命令 1document.execCommand(&#x27;copy&#x27;); 此时理应是好的，但是实验发现，只有第一次能成功复制，第二次就会报错： Discontiguous selection is not supported. 翻了翻文档发现每次都需要重置选区，于是加上 6.重置选区 1window.getSelection().removeAllRanges(); 即可。 我在Ng2 中完整代码如下： 1234567891011121314151617private copy() &#123; window.getSelection().removeAllRanges(); const EL = this.el.nativeElement.querySelector(&#x27;.code&#x27;); const range = document.createRange(); range.selectNode(EL); setTimeout(() =&gt; &#123; window.getSelection().addRange(range); document.execCommand(&#x27;copy&#x27;); // 防止出现文档选中状态，先取消一次。 window.getSelection().removeAllRanges(); &#125;, 0); // range.detach(); this.btnText = &#x27;已复制&#x27;; &#125; 兼容性chrome [✔️]Safari [✔️]IE [9+]Opera[9+]Firefox [1.0+] 参考文章： https://developer.mozilla.org/zh-CN/docs/Web/API/Range https://developer.mozilla.org/zh-CN/docs/Web/API/Document/execCommand","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhukejin.com/categories/JavaScript/"}],"tags":[]},{"title":"丙申杂诗-夜居大明山","slug":"丙申杂诗-夜居大明山","date":"un55fin55","updated":"un00fin00","comments":true,"path":"2016/丙申杂诗-夜居大明山/","permalink":"https://zhukejin.com/2016/%E4%B8%99%E7%94%B3%E6%9D%82%E8%AF%97-%E5%A4%9C%E5%B1%85%E5%A4%A7%E6%98%8E%E5%B1%B1/","excerpt":"夜居大明山，云栖鸟兽眠。月涌星河壮，江流天地宽。将炙芳桂下，清歌疏影前。长风九万里，飒踏碧波间。","text":"夜居大明山，云栖鸟兽眠。月涌星河壮，江流天地宽。将炙芳桂下，清歌疏影前。长风九万里，飒踏碧波间。","categories":[{"name":"Verses","slug":"Verses","permalink":"https://zhukejin.com/categories/Verses/"}],"tags":[]},{"title":"Angular2 动态的创建组件并插入到Shadow Dom中","slug":"Angular2DynamicLoadComponent","date":"un33fin33","updated":"un00fin00","comments":true,"path":"2016/Angular2DynamicLoadComponent/","permalink":"https://zhukejin.com/2016/Angular2DynamicLoadComponent/","excerpt":"作者随时修改，为方便读者追本朔源，转载请保留地址。 前言： 为什么会有这个需求？ 因为在开发组件中，难免会有一些组件是需要动态生成的，以减少Document中Dom 数量，节省内存开支。 例如全局的 message 组件、Alert 组件、Notice 组件等。 angular2 中如何动态的编译Template？ 在 Ng2 中， 废除了 $compiled 这个方法，用户将不能直接编译模板，如果想动态的创建组件，必须借助 组件工厂 (componentFactoryResolver) 如何动态创建一个组件：","text":"作者随时修改，为方便读者追本朔源，转载请保留地址。 前言： 为什么会有这个需求？ 因为在开发组件中，难免会有一些组件是需要动态生成的，以减少Document中Dom 数量，节省内存开支。 例如全局的 message 组件、Alert 组件、Notice 组件等。 angular2 中如何动态的编译Template？ 在 Ng2 中， 废除了 $compiled 这个方法，用户将不能直接编译模板，如果想动态的创建组件，必须借助 组件工厂 (componentFactoryResolver) 如何动态创建一个组件： 这里以 Tooltip 组件为例 首先需要准备一个组件内容(用来插入到页面中的动态组件) 这个组件就是很常规的组件， 没有什么特别的东西,只需要准备一些变量同步Template即可。 12345678910111213141516import &#123; Component &#125; from &#x27;@angular/core&#x27;;@Component(&#123; selector: &#x27;pxx-tooltip-container&#x27;, templateUrl: &#x27;./tooltip.html&#x27;, styleUrls: [&#x27;./tooltip.scss&#x27;],&#125;)export class TooltipContainer &#123; _top: any; _left: any; _state = &#x27;&#x27;; message: string; placement: &#x27;top&#x27; | &#x27;bottom&#x27; | &#x27;left&#x27; | &#x27;right&#x27; = &#x27;top&#x27;; _show: boolean = false;&#125; 将这个内容组件添加到Module 中，这一步主要是将这个组件存入 Angular 的工厂缓存中。 App.module （或者是其他的Module，甚至是这个组件自身的Module 都可以，只要最终在AppModule 中 import）, 我这里是组件自身的Module，最终导入到App.Module中。 123456789101112131415161718192021222324// TooltipModuleNgModule(&#123; imports: [ TooltipModule ], declarations: [ TooltipContainer ], exports: [ TooltipContainer ], entryComponents: [ TooltipContainer // 这里很重要，将这个组件放入Angular 工厂缓存中 ]&#125;)export class SharedModule &#123; static share(): ModuleWithProviders &#123; return &#123; ngModule: SharedModule, providers: [] &#125;; &#125;&#125; 建立一个中转组件、或者 service 来操作生成的组件， 这里我创建了一个 Tooltip.component.ts 的组件来做中转，也是用户真实使用的组件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108import &#123; Component, Input, HostListener, ComponentRef, ComponentFactoryResolver, ApplicationRef, ViewContainerRef, ReflectiveInjector&#125; from &#x27;@angular/core&#x27;;import &#123; TooltipContainer &#125; from &#x27;./tooltip.container&#x27;;@Component(&#123; selector: &#x27;pxx-tooltip&#x27;, template: &#x27;&lt;ng-content&gt;&lt;/ng-content&gt;&#x27;,&#125;)export class TooltipComponent &#123; container: ComponentRef&lt;any&gt;; @Input() message: string; @Input() placement: &#x27;top&#x27; | &#x27;bottom&#x27; = &#x27;top&#x27;; private _top: any; private _left: any; constructor(private componentFactoryResolver: ComponentFactoryResolver, private appRef: ApplicationRef) &#123; &#125; // 给中转组件绑定鼠标移入事件 @HostListener(&#x27;mouseenter&#x27;, [&#x27;$event.target&#x27;]) enter(el) &#123; // 当CreateTips 执行完毕后计算位置 this._createTips().then( () =&gt; &#123; this._getOffset(el); &#125;); //添加一个进入动画， 200ms 后移除 this._createTimeout(&#x27;enter&#x27;, 200); // 通滚 instance 控制动态组件的属性，显示组件。 this.container.instance._show = true; &#125; @HostListener(&#x27;mouseleave&#x27;, [&#x27;$event.target&#x27;]) leave() &#123; // 留 80 ms 给动画效果, 然后摧毁组件 this._createTimeout(&#x27;leave&#x27;, 80, () =&gt; &#123; this.container.destroy(); this.container = null; &#125;); &#125; private _createTips&lt;T&gt;(): Promise&lt;T&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; if (!this.container) &#123; if (!this.appRef[&#x27;_rootComponents&#x27;].length) &#123; const err = new Error(&#x27;AppRoot 未找到.&#x27;); console.error(err); reject(err); &#125; // 查找Body 的位置 let appContainer: ViewContainerRef = this.appRef[&#x27;_rootComponents&#x27;][0][&#x27;_hostElement&#x27;].vcRef; let providers = ReflectiveInjector.resolve([ // 此处创建提供商, 但是这个组件不需要 provider ]); // 创建并加载ToolTipContainer 组件，这里从Factory 中讲组件提取出来，创建组件。 let tooltipFactory = this.componentFactoryResolver.resolveComponentFactory(TooltipContainer); let childInjector = ReflectiveInjector.fromResolvedProviders(providers, appContainer.parentInjector); this.container = appContainer.createComponent(tooltipFactory, appContainer.length, childInjector); this.container.instance.placement = this.placement; this.container.instance.message = this.message; // resolve 加入异步队列， 模拟一个 nextTick 的操作，当Angular 执行完下一个时间循环后调用。 setTimeout(() =&gt; resolve(), 0); &#125; // resolve(); &#125;); &#125; /** * 这里是计算 tooltipContaine 的显示坐标的 */ private _getOffset(el) &#123; let tooltip = &lt;HTMLElement&gt;document.querySelector(&#x27;#tooltip&#x27;); if (this.placement == &#x27;top&#x27;) &#123; this._left = (el.getBoundingClientRect().left + (el.offsetWidth - tooltip.offsetWidth) / 2) + &#x27;px&#x27;; this._top = el.getBoundingClientRect().top - el.offsetHeight - tooltip.offsetHeight + (el.offsetHeight / 1.28) + &#x27;px&#x27;; &#125; else if (this.placement == &#x27;bottom&#x27;) &#123; this._left = (el.getBoundingClientRect().left + (el.offsetWidth - tooltip.offsetWidth) / 2) + &#x27;px&#x27;; this._top = el.getBoundingClientRect().top + el.offsetHeight + &#x27;px&#x27;; &#125; // instance this.container.instance._left = this._left; this.container.instance._top = this._top; &#125; private _createTimeout(state, delay, cb?: Function) &#123; this.container.instance._state = state; setTimeout(() =&gt; &#123; cb &amp;&amp; cb(); &#125;, delay); &#125;&#125; 将 TooltipComponent 这个中转组件也添加进APPModule 使用： 1&lt;pxx-tooltip message=&quot;这是一个优雅的提示&quot;&gt;Hover &lt;/pxx-tooltip&gt; ** 关于方法二 ** 这篇文章被我命名为 方法一， 所以还会有方法二。相对于上文这种方法， 方法二功能更强大，然而更死板。方法二的使用的核心API是 compileModuleAndAllComponentsAsync RuntimeCompiler.方法二相对于方法一： 好处就是不用每次把需要动态加载的组件放到 entryComponent 中缓存。但是需要动态的创建 ComponentFactory，完全的构造一个新的Module，这个Module 自然就包含了动态创建的组件。 坏处就是创建的Module 完全独立，无论作用域、Module通信等。也就意味着创建出来的Module无法使用外部Module 已经 import 过的模块、指令、服务、组件等，这真让人感到悲伤。。 那么方法二有什么用呢？ 个人觉得应用场景是用与解决动态的切换组件. 附编辑于 2017-11 经过 Angular2 -&gt; Angular4 -&gt; Angular5 的频繁变更，上述所用 this.appRef[&#39;_rootComponents&#39;][0][&#39;_hostElement&#39;].vcRef 这些非官方 public API 已经失效。 现方法为：this.appRef.components[0].instance.viewContainerRef;. 目测为 stable ，毕竟没有下划线了。 另外： 在官方文档中发现了一个新的方法： ReflectiveInjector.resolveAndCreate, 所以或许有更好的解法。本文权作参考即可。 参见 https://angular.io/api/core/ReflectiveInjector","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhukejin.com/categories/JavaScript/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"https://zhukejin.com/tags/Angular/"}]},{"title":"webpack&React 性能优化","slug":"webpack-React-性能优化","date":"un66fin66","updated":"un00fin00","comments":true,"path":"2016/webpack-React-性能优化/","permalink":"https://zhukejin.com/2016/webpack-React-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/","excerpt":"关于 Webpack + React 的性能优化 这篇文章很早就想写了，但是由于工作太忙，一直挤不出时间。正好趁月底挤干货的时间弄出来一篇。由于本文内容是作者自互联网收集 + 实践与发散思维得出，故可能随时会更新修改，为了方便读者追本索源，转载请保留头部，谢谢本文链接 另： 本文不是新手教程，关于 WebPack 如何入门配置、React Jsx 的Loader 等，请移步这里： 使用Jsx 或者 优化开发-Webpack &amp; Jsx","text":"关于 Webpack + React 的性能优化 这篇文章很早就想写了，但是由于工作太忙，一直挤不出时间。正好趁月底挤干货的时间弄出来一篇。由于本文内容是作者自互联网收集 + 实践与发散思维得出，故可能随时会更新修改，为了方便读者追本索源，转载请保留头部，谢谢本文链接 另： 本文不是新手教程，关于 WebPack 如何入门配置、React Jsx 的Loader 等，请移步这里： 使用Jsx 或者 优化开发-Webpack &amp; Jsx 先看一下最基础 Webpack 配置： module.exports = &#123; entry: &#39;entry.jsx&#39;, output: &#123; path: path.join(__dirname, &#39;/dist&#39;), filename: &#39;bundle.js&#39; &#125;, resolve: &#123; extensions: [&#39;&#39;, &#39;.js&#39;, &#39;.jsx&#39;, &#39;.scss&#39;] &#125;, module: &#123; loaders: [ &#123; test: /\\.jsx?$/, exclude: /(node_modules|bower_components)/, loader: &#39;babel&#39;, query: &#123; presets: [&#39;react&#39;, &#39;es2015&#39;] &#125; &#125;, &#123; test: /\\.css$/, &#39;style!css&#39; &#125;, &#123; test: /\\.scss$/, &#39;style!css!sass?sourceMap&#39;&#125;, ] &#125; &#125; 文件结果： bundle.js : 852kb. 心想并没有什么复杂的代码，为什么有852kb！ 目前情况： Webpack + react 文件打包出来过大，动则 几百k 上兆。原因分析： 在使用 import css 的时候，Webpack Css 直接作为模块打包到js中。 所有Js 模块 + 依赖都会打包到一个文件，导致文件很大。 React、React-dom 文件过大 解决方案： 分离 css 文件,将css 单独打包。 //使用 ExtractTextPlugin 插件，将css 打包进一个文件 plugins: [ new ExtractTextPlugin(&quot;bundle.css&quot;), ], //同时需要在 loader 里加上方法，如下 &#123; test: /\\.css$/, loader: ExtractTextPlugin.extract(&#39;style-loader&#39;, &#39;css-loader&#39;) &#125;, &#123; test: /\\.scss$/, loader: ExtractTextPlugin.extract(&#39;style-loader&#39;,&#39;css!sass?sourceMap&#39;)&#125;, 此时看下文件大小，变成： bundle.css - 56kb bundle.js -796kb 好像作用还不是很大… - -！ 那么执行第二步 ，公用JavaScript 模块分离 如果文件 file1 使用了 a 模块， 文件 file2 也使用了 a 模块，那么这个模块就可以认为是公用模块，当然这个数量也可以自己定义，可以使用 CommonsChunkPlugin 分片插件来分离。 //同样是插件 new webpack.optimizes.CommonsChunkPlugin(&#39;vendor&#39;, &#39;vendor.js&#39;) 此时看下效果，文件变成： bundle.css - 56kb bundle.js -760kb vendor.js -36kb 移出了 36kb，效果不是很明显。 最好是把 React、React-dom 这种移到 vendor.js 中让他去缓存。 //修改 entry 为： entry: &#123; app: path.resolve(__dirname, &#39;entry.jsx&#39;), vendor: [&#39;react&#39;, &#39;react-dom&#39;] &#125;, 变成： bundle.js - 16kb vendor.js - 780kb 压缩 JavaScript 代码 通过 UglifyJsPlugin 插件 new webpack.optimize.UglifyJsPlugin({ output: { comments: false, &#x2F;&#x2F; remove all comments }, compress: { warnings: false } }) 压缩后，文件有明显瘦身： bundle.js -16kb vendor.js -750kb 但是还是不太明显， 原因可能是 react、react-dom 本身就是min 状态，在压缩一遍也小不了多少。 那么就从 react 上入手，发现react 里面存在很多注释，警告等，是一个开发版本。那么如何切换成生产版本呢 通过 webpack.DefinePlugin 的process.env 来切换成生产版本 new webpack.DefinePlugin(&#123; &#39;process.env&#39;: &#123; NODE_ENV: JSON.stringify(process.env.NODE_ENV), &#125;, &#125;), 当然，这里的process.env.NODE_ENV 也可以直接换成 production，就不用在 build脚本里赋值了，如果按上面的写法，build 里需要赋值： &quot;build&quot;: &quot;set NODE_ENV=production&amp;&amp;webpack -p --progress --colors&quot; 注意： 这里是 windows的写法，如果是 mac、linux 需要这样写 —— NODE_ENV=production webpack -p --progress --colors 看一眼，这个影响最大，编译完成后： bundle.js -16kb vendor.js -144kb 上面四条已经差不多解决了文件过大的问题，但是还有童鞋发现，编译速度好慢.. 为什么？ 编译速度慢是因为项目中引用了很多的模块，这些模块又互相依赖， webpack 去处理依赖关系的时候， 要去 npm中搜索， 硬盘搜索很占用资源。所以可以通过 alias 配置来解决 var node_modules = path.resolve(__dirname, &#39;node_modules&#39;); var pathToReact = path.resolve(node_modules, &#39;react/dist/react.min&#39;); resolve: &#123; alias: &#123; &#39;react&#39;: pathToReact &#125; &#125;, 这样等于直接为 webpack 指定了目录，上述只是配置了 react ， 如果需要，可以酌情配置其他库。 注： 上述所有插件，都需要 npm install 。 写在最后优化了这么多，还有没有优化的空间？当然有。 服务端渲染 首屏优化 异步加载模块 …. 还有很多 代码在这里： https://github.com/zhukejin/WebPack-Demo 公司即将倒闭，求一个工作机会。 如何联系我？点击此处发送邮件:To:zhukejin@msn.com","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhukejin.com/categories/JavaScript/"}],"tags":[{"name":"React","slug":"React","permalink":"https://zhukejin.com/tags/React/"},{"name":"Webpack","slug":"Webpack","permalink":"https://zhukejin.com/tags/Webpack/"}]},{"title":"如何快速的创建一个包含100个元素的数组","slug":"creat-100-array","date":"un55fin55","updated":"un00fin00","comments":true,"path":"2016/creat-100-array/","permalink":"https://zhukejin.com/2016/creat-100-array/","excerpt":"可能随时修改，若需转载请保留此头部，以便读者追本朔源。 本文地址 ： https://zhukejin.com/2016/creat-100-array/ 如题， 最初见到的问题是如何创建100个为元素为0 的数组研究了一系列的方法，包含Es6 新的API ，不得不说， ES6 好强大！如果问一个新手，那么得到的回答极有可能就是 循环，当然循环也无可厚非，毕竟能实现就行，但是我们如果闲的话，还是可以探讨一下到底有多少中方式可以解决这个问题","text":"可能随时修改，若需转载请保留此头部，以便读者追本朔源。 本文地址 ： https://zhukejin.com/2016/creat-100-array/ 如题， 最初见到的问题是如何创建100个为元素为0 的数组研究了一系列的方法，包含Es6 新的API ，不得不说， ES6 好强大！如果问一个新手，那么得到的回答极有可能就是 循环，当然循环也无可厚非，毕竟能实现就行，但是我们如果闲的话，还是可以探讨一下到底有多少中方式可以解决这个问题 循环 123456var arr = [];for (var i=0; i&lt;99; i++) &#123; arr.push(0)&#125;//可以吗？ 当然可以。 或者使用其他的什么循环 那么有其他方法吗？ 当然有。核心围绕在 new Array() 上 Array构造器 如上第一个循环的时候，就是用了 new Array(100) 这样的构造器，但是这样创建出来的数组只是一个 undefined x 100的集合 1Array(100) //[undefined × 100] ECMAScript-262 中对 Array.prototype.map 的方法描述有一句话 callbackfn is called only for elements of the array which actually exist; it is not called for missing elements of the array. 在为数组中每个元素执行callbackfn 之前，会先判断这个元素是否在数组中实际存在（actually exist），判断的方法就是调用内部方法[[HasProperty]]。 不过没关系，我们可以进行一些简单的处理 split分割 1234567891011//创建一个100个元素的数组，此时不具有Array 的 prototype, 然后通过 join 和 split 来生成Array(100).join(0).split(&#x27;&#x27;)//或者&#x27;0&#x27;.repeat(100).split(&#x27;&#x27;)//或者(1 &lt;&lt; 24).toString(2).replace(/\\d/g, &#x27;0000&#x27;).split(&#x27;&#x27;)//什么？ 你说这些出来元素都是字符串？要Number ？Array(100).join(0).split(&#x27;&#x27;).map(Number) 可以了吧 Array.fill 12345678// Es6 的新方法 Array.prototype.fillArray(100).fill(0)//tip[].fill.call(&#123;length: 100&#125;, 0)//这时候就可以用 Array.from 、 Array.prototype.slice.call 来转换成数组了Array(100).fill(0).map(x=&gt;x); Array.from + map 12345//构造器创建的undefined 集合无法遍历，那么就来转换一下Array.from(Array(100)).map(x=&gt;0)//或者Array.from(&#123;length: 100&#125;).map(x=0) Array.from + mapFn (from 的第二个参数) 1Array.from(&#123;length:100&#125;, x=&gt;0) Array.apply + map 1234Array.apply(null, Array(100)).map(x=&gt;0)//或者Array.apply(null,&#123;length:100&#125;).map(x=0) 类型化数组 12345//它的元素默认初始化为0。new Int8Array(100);//甚至Array.prototype.slice.call(new Uint8Array(100)) Spread 拓展运算符 1[...Array(100)].map(x=0); 延伸一下，如果是求每个元素是他的下标 （部分来自知乎） Object.keys 12345678910Object.keys(Array.apply(null,&#123;length:100&#125;));//笔者补充，其实可以这样Object.keys(new Int8Array(100))//或者这样Object.keys(String(Array(101)));//甚至这样Object.keys(&#x27;0&#x27;.repeat(100)) Array.from + keys 1Array.from(Array(100).keys()) Spread + keys 1[...Array(100).keys()] Array.from + Generator 12345function* angry(i) &#123; yield i; if (i &lt; 99) &#123; yield* angry(i + 1); &#125;&#125;;Array.from(angry(0)); 变异递归 1(function(v,i)&#123;if(i&gt;0)arguments.callee(v,i-1);v.push(i);return v&#125;)([],99); 奇葩一点的方法： 1234567891011121314Number.prototype[Symbol.iterator] = function() &#123; return &#123; v: 0, e: this, next() &#123; return &#123; value: this.v++, done: this.v &gt; this.e &#125; &#125; &#125;&#125;[...100] Y combinator (群友提供) 12345678910111213141516(function (excited) &#123; return function (f) &#123; return f(f); &#125;(function (f) &#123; return excited(function (x) &#123; return (f(f))(x); &#125;); &#125;);&#125;)(function (excited) &#123; return function(i) &#123; return (i &lt; 0) ? [] : excited(i - 1).concat(i); &#125;&#125;)(99);// es6简化后的写法((excited) =&gt; ((f) =&gt; f(f))((f) =&gt; excited((x) =&gt; (f(f))(x))))((excited) =&gt; (i) =&gt; (i&lt;0 ? [] : excited(i-1).concat(i)))(99) 写在最后 可能你看到这里会觉得内心毫无波动，甚至有一点想笑：“妈哒智障，研究这些东西干什么，会用循环就够了”但是基于我的求知欲，看到这些东西就有兴趣就追根问底，而且在写这篇文章的时候，确实安利到不少新的黑科技。也巩固了一遍 Array.from ， Object.keys 这些Es6 的新API甚至 Y combinator 这样的黑魔法。 另外 如果有不对的，漏的，请补充。 参考资料 https://www.zhihu.com/question/41493194?sort=created","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhukejin.com/categories/JavaScript/"}],"tags":[]},{"title":"滚动条跳动问题","slug":"打开模态框导致背景跳动的问题","date":"un44fin44","updated":"un00fin00","comments":true,"path":"2016/打开模态框导致背景跳动的问题/","permalink":"https://zhukejin.com/2016/%E6%89%93%E5%BC%80%E6%A8%A1%E6%80%81%E6%A1%86%E5%AF%BC%E8%87%B4%E8%83%8C%E6%99%AF%E8%B7%B3%E5%8A%A8%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"通过js 控制页面的 overflow: hidden 与 overflow: auto 切换的时候，由于页面总宽度变化导致文档跳动。 解决方案一： （纯CSS）在页面主体元素上加上 1margin-left: calc(100vw - 100%) !important; 这个方法需要一个定宽的主体元素，例如总的 wrap。如果不是定宽而是自适应的，就会在左边出现与滚动条同宽的空白列。 其次： calc是CSS3中的计算，IE10+浏览器支持","text":"通过js 控制页面的 overflow: hidden 与 overflow: auto 切换的时候，由于页面总宽度变化导致文档跳动。 解决方案一： （纯CSS）在页面主体元素上加上 1margin-left: calc(100vw - 100%) !important; 这个方法需要一个定宽的主体元素，例如总的 wrap。如果不是定宽而是自适应的，就会在左边出现与滚动条同宽的空白列。 其次： calc是CSS3中的计算，IE10+浏览器支持 解决方案二： （JS控制）通过设置 body 的scroll：hidden 与 padding-left 达到类似的效果 在打开 模态框的时候， 设置 12body.paddingRight: window.innerWidth - document.documentElement.clientWidth,body.overflowY: &#x27;hidden&#x27; 关闭模态框的时候，设置 12body.paddingRight: 0,body.overflowY: auto 即可。 innerWidth有兼容性问题, IE8无法正常使用. 解决兼容性的方法: 12345678910111213141516function getScrollBarWidth () &#123; var oP = document.createElement(&#x27;p&#x27;), styles = &#123; width: &#x27;100px&#x27;, height: &#x27;100px&#x27; &#125;, i, clientWidth1, clientWidth2, scrollbarWidth; for (i in styles) oP.style[i] = styles[i]; document.body.appendChild(oP); clientWidth1 = oP.clientWidth; oP.style.overflowY = &#x27;scroll&#x27;; clientWidth2 = oP.clientWidth; scrollbarWidth = clientWidth1 - clientWidth2; oP.parent.removeChild(oP); return scrollbarWidth;&#125;","categories":[{"name":"CSS","slug":"CSS","permalink":"https://zhukejin.com/categories/CSS/"}],"tags":[]},{"title":"甲午杂诗-其二","slug":"甲午杂诗-其二","date":"un33fin33","updated":"un00fin00","comments":true,"path":"2016/甲午杂诗-其二/","permalink":"https://zhukejin.com/2016/%E7%94%B2%E5%8D%88%E6%9D%82%E8%AF%97-%E5%85%B6%E4%BA%8C/","excerpt":"","text":"天色青青向昏黄凉风阵阵弄西窗垂帘欲滴仲夏雨落入行人颈间凉","categories":[{"name":"Verses","slug":"Verses","permalink":"https://zhukejin.com/categories/Verses/"}],"tags":[]},{"title":"CSS3 rgba() 兼容IE","slug":"css3-rgba-ie","date":"un11fin11","updated":"un00fin00","comments":true,"path":"2015/css3-rgba-ie/","permalink":"https://zhukejin.com/2015/css3-rgba-ie/","excerpt":"本文系作者整合互联网资料加个人理解所写，或随时更改， 若需转载请保留此行，以便后来者追本朔源本文地址：http://zhukejin.com/2017/12/01/creat-100-array/ 不登高山， 不知山之高也。之前无过多接触CSS， 固步自封之下也不觉得CSS多么强大， 后来逐渐了解了点CSS3，觉得CSS已有发展为一门独立语言的潜力。 临渊羡鱼，不如退而结网， 总是羡慕别人的网站特效多好， 还是自己来研究CSS3吧。 CSS3效果好归好， 但是总是能碰到一些恶心的兼容问题，比如当下的 rgba … 12345.wrap &#123; background: rgba(0,0,0,0.8); width: 100px; height: 100px;&#125;","text":"本文系作者整合互联网资料加个人理解所写，或随时更改， 若需转载请保留此行，以便后来者追本朔源本文地址：http://zhukejin.com/2017/12/01/creat-100-array/ 不登高山， 不知山之高也。之前无过多接触CSS， 固步自封之下也不觉得CSS多么强大， 后来逐渐了解了点CSS3，觉得CSS已有发展为一门独立语言的潜力。 临渊羡鱼，不如退而结网， 总是羡慕别人的网站特效多好， 还是自己来研究CSS3吧。 CSS3效果好归好， 但是总是能碰到一些恶心的兼容问题，比如当下的 rgba … 12345.wrap &#123; background: rgba(0,0,0,0.8); width: 100px; height: 100px;&#125; 在 chrome ， firefox ， IE10 下开开心心的跑了起来， 但是在 ie8上是不会出现背景的，为什么？rgba 做为css3 属性，例行不支持IE，如果想要解决这个问题， 需要调用 IE的 “滤镜”， filter属性。 123456.wrap &#123; background: rgba(0,0,0,0.8); width: 100px; height: 100px; filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=#BF000000,endColorstr=#BF000000);&#125; 关于 progid:DXImageTransform.Microsoft.gradient 的属性：#### enabled: 可选项。布尔值(Boolean)。设置或检索滤镜是否激活。 true | false true: 默认值。滤镜激活。 false:滤镜被禁止。 startColorStr:可选项。字符串(String)。设置或检索色彩渐变的开始颜色和透明度。 其格式为 #AARRGGBB 。 AA 、 RR 、 GG 、 BB 为十六进制正整数。取值范围为 00 - FF 。 RR 指定红色值， GG 指定绿色值， BB 指定蓝色值，参阅 #RRGGBB 颜色单位。 AA 指定透明度。 00 是完全透明。 FF 是完全不透明。超出取值范围的值将被恢复为默认值。 取值范围为 #FF000000 - #FFFFFFFF 。默认值为 #FF0000FF 。不透明蓝色。 EndColorStr:可选项。字符串(String)。设置或检索色彩渐变的结束颜色和透明度。参阅 startColorStr 属性。默认值为 #FF000000 。不透明黑色。 特性： Enabled:可读写。布尔值(Boolean)。参阅 enabled 属性。 GradientType:可读写。整数值(Integer)。设置或检索色彩渐变的方向。1 | 0 1 &#x3D; 默认值。水平渐变。 0 &#x3D; 垂直渐变。 StartColorStr:可读写。字符串(String)。参阅 startColorStr 属性。 StartColor:可读写。整数值(Integer)。设置或检索色彩渐变的开始颜色。 取值范围为 0 - 4294967295 。 0 为透明。 4294967295 为不透明白色。 EndColorStr:可读写。字符串(String)。设置或检索色彩渐变的结束颜色和透明度。参阅 startColorStr 属性。默认值为 #FF000000 。不透明黑色。 EndColor:可读写。整数值(Integer)。设置或检索色彩渐变的结束颜色。 取值范围为 0 - 4294967295 。 0 为透明。 4294967295 为不透明白色。当在脚本中使用此特性时，也可以用十六进制格式： 0xAARRGGBB 。 IE4.0以上支持的滤镜属性表 滤镜效果 描述 ：##### Alpha 设置透明度 Blru 建立模糊效果 Chroma 把指定的颜色设置为透明 DropShadow 建立一种偏移的影象轮廓，即投射阴影 FlipH 水平反转 FlipV 垂直反转 Glow 为对象的外边界增加光效 Grayscale 降低图片的彩色度 Invert 将色彩、饱和度以及亮度值完全反转建立底片效果 Light 在一个对象上进行灯光投影 Mask 为一个对象建立透明膜 Shadow 建立一个对象的固体轮廓，即阴影效果 Wave 在X轴和Y轴方向利用正弦波纹打乱图片 Xray 只显示对象的轮廓 filter作为微软独有的一个属性， 不得不说，IE其实还是很强大的， 只不过走了非同寻常的道路， 没有被 w3c 规范起来而已..(看起来跟党走，才是王道)","categories":[{"name":"CSS","slug":"CSS","permalink":"https://zhukejin.com/categories/CSS/"}],"tags":[]},{"title":"关于Highchart error #19","slug":"关于Highchart-error-19","date":"un33fin33","updated":"un00fin00","comments":true,"path":"2014/关于Highchart-error-19/","permalink":"https://zhukejin.com/2014/%E5%85%B3%E4%BA%8EHighchart-error-19/","excerpt":"","text":"踩过的坑和走过的路本文地址转载请注明 最近业务上需要画一些表格，使用了HighChart，总体上还不错，但是总有一些坑需要一个个的去踩… 今天在画一个21个指标的折线图的时候遇到了一个问题：首先自定义x轴为类目， 1[&quot;201301&quot;,&quot;201302&quot;,&quot;201303&quot;,&quot;201304&quot;,&quot;201305&quot;,&quot;201306&quot;,&quot;201307&quot;,&quot;201308&quot;,&quot;201309&quot;,&quot;201310&quot;,&quot;201311&quot;,&quot;201312&quot;,&quot;201401&quot;,&quot;201402&quot;,&quot;201403&quot;,&quot;201404&quot;,&quot;201405&quot;,&quot;201406&quot;,&quot;201407&quot;,&quot;201408&quot;,&quot;201409&quot;,&quot;201410&quot;] 然后发现报错: Highcharts Error #19Too many ticksThis error happens when you try to apply too many ticks to an axis,specifically when you add more ticks than the axis pixel length.In practice, it doesn’t make sense to add ticks so densely that they can’t be distinguished from each other.One cause of the error may be that you set a tickInterval that is too small for the data value range.In general, tickPixelInterval is a better option, as it will handle this automatically.Another case is if you try to set categories on a datetime axis,which will result in Highcharts trying to add one tick on every millisecond since 1970. 这段的意思大概就是说图表上的点太密集了巴拉巴拉，如果太密集看起来不方便就没有作图的意义了巴拉巴拉… 去网上搜索也没有发现有人提出解决方案。 从报错字面意思上分析，是由于时间点过于密集而发生错误，于是我就去注释掉所有与时间有关的代码，在不停的尝试修改各个地方代码后终于发现原因所在： 12345678910......plotOptions: &#123; series: &#123; pointStart: Date.UTC(&lt;?php echo $pointStart; ?&gt;), pointInterval: 24 * 3600 * 1000, // one day events:&#123;...... 这段代码存在的意义在于之前计算x轴为默认时间点开始后每一天时间为一个点 但是如果自定义了类目后，就出现了 #19… 具体详情由于时间问题没有深究，先留一坑站个位置，以后慢慢研究。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhukejin.com/categories/JavaScript/"}],"tags":[{"name":"HighCharts","slug":"HighCharts","permalink":"https://zhukejin.com/tags/HighCharts/"}]},{"title":"七种情况下 This 的指向问题","slug":"JavaScript-this","date":"un33fin33","updated":"un00fin00","comments":true,"path":"2014/JavaScript-this/","permalink":"https://zhukejin.com/2014/JavaScript-this/","excerpt":"为方便读者追本朔源，转载请注明本文地址来源，谢谢。 本文地址： http://zhukejin.com/2014/09/24/JavaScript-this/ this 是一个动态指针，它指向当前作用域对象，如果当前定义对象的作用域没有发生变化，那么this就会指向当前对象。This可以存在于任何位置，并不局限与对象、方法内，也可以是其他特殊的上下文环境。 本文实验了下述七种情况： 在函数中的 This 在构造器中的This 函数的引用和调用中this的变数 call 和 apply 对 this的影响 原型继承中的 This 异步调用的 This 定时器中的 This 被Evel() 方法解析的 This","text":"为方便读者追本朔源，转载请注明本文地址来源，谢谢。 本文地址： http://zhukejin.com/2014/09/24/JavaScript-this/ this 是一个动态指针，它指向当前作用域对象，如果当前定义对象的作用域没有发生变化，那么this就会指向当前对象。This可以存在于任何位置，并不局限与对象、方法内，也可以是其他特殊的上下文环境。 本文实验了下述七种情况： 在函数中的 This 在构造器中的This 函数的引用和调用中this的变数 call 和 apply 对 this的影响 原型继承中的 This 异步调用的 This 定时器中的 This 被Evel() 方法解析的 This 在函数中的This：在实函数中分属两种情况，一种是 Sloppy 模式， 一种是 Strict模式。 什么是Strict模式? Sloppy 模式下: (function test() &#123; console.log(this) // window &#125;)() Strict 模式下： (function test() &#123; &#39;use strict&#39;; console.log(this) // undefined &#125;)() 在构造器中的This：var getThis; var a = function() &#123; getThis = this; &#125; var b = new a(); console.log(getThis); // a&#123;&#125; console.log(getThis === b); // true 此处通过 new来新建一个对象，并将这个对象通过 this 传入构造器中。 附：Javascript New 的操作原理（这里是出处）： function newOperator(Constr, args) &#123; var thisValue = Object.create(Constr.prototype); // (1) var result = Constr.apply(thisValue, args); if (typeof result === &#39;object&#39; &amp;&amp; result !== null) &#123; return result; // (2) &#125; return thisValue; &#125; 函数的引用和调用函数的引用和调用分属两种不同的概念，虽然两者都无法改变函数的定义作用域，但是引用函数可以改变函数的执行作用域，而调用函数是不会改变函数的执行作用域的,如下： var o = &#123; name: &quot;这是一个对象&quot;, f : function () &#123; return this; &#125; &#125; o.ol = &#123; name: &quot;这又是一个对象&quot;, me : o.f //引用上个对象的方法 &#125; var who = o.ol.me(); // ol&#123;&#125; 此处this指向的是当前执行域对象 ol， 如果把对象 ol 的 me 属性值改为函数调用： o.ol = &#123; name : &quot;这又是一个对象&quot;, me : o.f() // o &#125; 此处this 所代表的是定义函数时所在的作用域对象。 call 和 apply ：call 和 apply 方法能够强制的改变函数的执行作用域，使其作用域指向所传递的参数对象，所以函数中所包含的this关键字也会指向参数对象 function f() &#123; alert(this.x + this.y); &#125; var o = &#123; x : 1, y : 2 &#125; f.call(o); 这里其实就通过 call 将函数中的 this指向变为传入的参数对象 o，所以函数中的this.x 也就是 o.x 原型继承：function base() &#123; this.m = function () &#123; return &quot;base&quot;; &#125;; this.a = this.m(); //基类的属性a 调用m方法 this.b = this.m; //基类的属性b 引用m方法 this.c = function ()&#123; //基类的方法c() ， 以闭包结构调用当前作用域中的m方法 return this.m(); &#125; &#125; function f () &#123; this.m = function () &#123; return &quot;f&quot;; &#125; &#125; f.prototype = new base(); var ff = new f(); console.log(ff.a); // base， 说明this.m() 中this指向 f 的原型对象 console.log(ff.b()); // base console.log(ff.c()); // f ， 说明this.m() 中this指向作用域对象 c为一个闭包体，在子类的实例中调用它时，他的返回值实际上已经成为实例对象的成员，闭包在哪里调用，其中包含的this就会指向哪里。 异步调用：var button = document.getElementById(&#39;button&#39;); var o = &#123;&#125;; o.f = function ()&#123; if(this == o) console.log(&quot;this == o&quot;); if(this == window) console.log(&quot;this == window&quot;); if(this == button) console.log(&quot;this == button&quot;); &#125; button.onclick = o.f; 这里的f() 中的this就不再指向o, 而是指向 button dom 对象。因为是被传递给按钮的事件处理函数之后再被调用的，函数的执行作用域发生了变化。 //通过事件绑定进行 if (window.attachEvent) button.attachEvent(&quot;onclick&quot;, o.f); else button.addEventListener(&quot;click&quot;, o.f, false) 实验结果是在符合 DOM标准的浏览器中，this 是指向button，但是在 ie 中，this是同时指向 window 和 button，因为attach是 ie的window方法，调用此方法的时候，执行作用域为全局，随后又被注册到按钮对象上，所以this会指向两个目标。 IE上这种情况很可能导致事件绑定的句柄丢失，为了防止这种情况，可以通过call 来强制指定 this 指向： button.attachEvent(&quot;onclick&quot;,function() &#123; o.f.call(button); //this 指向button &#125;); 当然可以强制指向 o 定时器异步调用的另一种形式就是使用定时器来调用函数，通过调用 window对象 的 setTimeout() 或者 setInterval() 方法来延期调用函数，例如： var o = &#123;&#125;; o.f = function () &#123; if (this == o) console.log(&quot;this == o&quot;); if (this == window) console.log(&quot;this == window&quot;); if (this == button) console.log(&quot;this == button&quot;); &#125; setTimeout(o.f, 1000); 程序在IE浏览器下的运行结果同上，this 同时指向 window和 button对象，原理和attachEvent() 一样。 在符合Dom 标准的浏览器中，this指向的是window对象，因为setTimeout() 方法是在全局作用域中被执行的，所以 this 指向window 对象。 eval () 中的 this：直接使用eval(), this 指向当前范围 var x = &#39;global&#39;; function directEval() &#123; &#39;use strict&#39;; var x = &#39;local&#39;; console.log(eval(&#39;x&#39;)); // local &#125; 通过call () 间接地调用eval(), this 指向全局范围 var x = &#39;global&#39;; function indirectEval() &#123; &#39;use strict&#39;; var x = &#39;local&#39;; console.log(eval.call(null, &#39;x&#39;)); // global console.log(window.eval(&#39;x&#39;)); // global console.log((1, eval)(&#39;x&#39;)); // global (1) var xeval = eval; console.log(xeval(&#39;x&#39;)); // global var obj = &#123; eval: eval &#125;; console.log(obj.eval(&#39;x&#39;)); // global &#125; 如有不对，请指正。 Email ： &#122;&#104;&#x75;&#107;&#101;&#106;&#105;&#x6e;&#x40;&#x6d;&#115;&#110;&#46;&#x63;&#111;&#x6d;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhukejin.com/categories/JavaScript/"}],"tags":[]},{"title":"Javascript 事件冒泡和捕获的一些探讨","slug":"JavaScript-event","date":"un55fin55","updated":"un00fin00","comments":true,"path":"2014/JavaScript-event/","permalink":"https://zhukejin.com/2014/JavaScript-event/","excerpt":"本文为笔者实验总结如有不正，请指点。 引文：偶然和朋友讨论了事件绑定冒泡和捕获的执行顺序，各持己见，久争不下。 于是实验一番_ 此为 HTML 代码： 12345&lt;body&gt; &lt;ul class=&quot;ulclass&quot;&gt; &lt;li class=&quot;li1class&quot;&gt;1&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;","text":"本文为笔者实验总结如有不正，请指点。 引文：偶然和朋友讨论了事件绑定冒泡和捕获的执行顺序，各持己见，久争不下。 于是实验一番_ 此为 HTML 代码： 12345&lt;body&gt; &lt;ul class=&quot;ulclass&quot;&gt; &lt;li class=&quot;li1class&quot;&gt;1&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt; 实验一：12345678910111213&lt;script type=&quot;text/javascript&quot;&gt; var $El = document.querySelector(&quot;.ulclass&quot;); var $El1 = document.querySelector(&quot;.li1class&quot;); //冒泡 $El.addEventListener(&quot;click&quot;,function()&#123; alert(&quot;ul&quot;); &#125;,false); //捕获 $El1.addEventListener(&quot;click&quot;,function()&#123; alert(&quot;li&quot;); &#125;,true);&lt;/script&gt; 实验分析：冒泡执行过程中是从最内层元素 li 开始往外冒泡，在 经过 li 一层元素后到达 ul 被触发。而捕获过程则一共经历 window-&gt; document -&gt; body -&gt; ul 四层元素后到达 li ，被触发，看起来好像是应该先弹出 ul ，然后再弹出 li。 实验结果：点击 li 内的 1 的时候，第一次弹出 “li”，第二次弹出 “ul” 。 猜想一 在冒泡事件和捕获事件同时存在的情况下，捕获事件优先级高一点。 为了验证这个猜想，再来做几个实验： 实验二12345678910111213&lt;script type=&quot;text/javascript&quot;&gt; var $El = document.querySelector(&quot;.ulclass&quot;); var $El1 = document.querySelector(&quot;.li1class&quot;); //捕获 $El.addEventListener(&quot;click&quot;,function()&#123; alert(&quot;ul&quot;); &#125;,true); //冒泡 $El1.addEventListener(&quot;click&quot;,function()&#123; alert(&quot;li&quot;); &#125;,false); &lt;/script&gt; 实验分析：如果上述猜想是正确的，那么这次的执行结果就应该是先弹出 “ul” 再弹出 “li”。 实验结果：先弹出 “ul” 再弹出 “li”。 实验四再来试一下两个事件都冒泡的情况： 123456789//冒泡$El.addEventListener(&quot;click&quot;,function()&#123; alert(&quot;ul&quot;);&#125;,false);//冒泡$El1.addEventListener(&quot;click&quot;,function()&#123; alert(&quot;li&quot;);&#125;,false); 实验分析：如果两个都为冒泡的情况下，点击后应从最里面的元素往外冒，也就是先弹出 li , 再弹出 ul. 实验结果：无误。 然后将两个事件都改成捕获，则先弹出 ul 再 弹出 li ，与预期完全一样。 实验五这里把本来在 ul 上绑定的事件放到 li 上，也就是 li 绑定两个事件，一个为冒泡，一个为捕获。 1234567891011var $El = document.querySelector(&quot;.ulclass&quot;); var $El1 = document.querySelector(&quot;.li1class&quot;); //冒泡 $El1.addEventListener(&quot;click&quot;,function()&#123; alert(&quot;冒泡&quot;); &#125;,false); //捕获 $El1.addEventListener(&quot;click&quot;,function()&#123; alert(&quot;捕获&quot;); &#125;,true); 实验分析：按照之前的猜测，应该是先弹出捕获，然后弹出冒泡。（如果是这样的话我也不会写这么多了…）实验结果：先弹出了 冒泡，然后弹出了捕获。 为什么？？ 猜想二 在同一个元素的绑定事件中，冒泡和捕获没有次序之分，遵循Javascript的执行顺序。 实验六为了进一步证实这个猜测…我们将冒泡和捕获的位置调换一下 1234567891011var $El = document.querySelector(&quot;.ulclass&quot;); var $El1 = document.querySelector(&quot;.li1class&quot;); //捕获 $El1.addEventListener(&quot;click&quot;,function()&#123; alert(&quot;捕获&quot;); &#125;,true); //冒泡 $El1.addEventListener(&quot;click&quot;,function()&#123; alert(&quot;冒泡&quot;); &#125;,false); 实验结果： 先捕获，后冒泡。 看似是这样了，但是在重复实验五 的时候，li下一级有一个元素 a ，直接点击 li 很符合上面的推测，但是在点击a元素的时候，先弹出了捕获。 为什么？？ 猜测三 在元素上同时绑定捕获事件和冒泡事件，如果通过此元素的子级元素触发，则优先触发捕获事件，若不通过此元素的子级元素触发，则按照Javascript执行顺序触发。 附： 冒泡经常用于需要绑定很多事件的时候，给他们父级元素绑定一个事件，可以有效的提高代码执行效率。比如： 123456789101112&lt;body&gt; &lt;div class=&quot;&quot;&gt; &lt;ul class=&quot;ulclass&quot;&gt; &lt;li class=&quot;li1class&quot;&gt;1&lt;/li&gt; &lt;li class=&quot;li1class&quot;&gt;1&lt;/li&gt; &lt;li class=&quot;li1class&quot;&gt;1&lt;/li&gt; ... ... &lt;li class=&quot;li1class&quot;&gt;1&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt; 假如此处有100个li，每个li元素上都绑定一个事件的话就验证影响了执行效率，那么就可以在ul 上绑定一个事件： 1234567&lt;script type=&quot;text/javascript&quot;&gt; var $El = document.querySelector(&quot;.ulclass&quot;); //冒泡 $El.addEventListener(&quot;click&quot;,function()&#123; console.log(event.target); &#125;,false);&lt;/script&gt; 其中 event.target 就是获取触发来源。it’ OK。 附二： 经网友描述： ###事件传播三阶段： capture phase （事件捕获） target phase （处于目标） bubbling phase （事件冒泡） 在 target phase，event handler 被调用的顺序不再遵循先捕获，后冒泡的原则，而是严格按照 event handler 注册的顺序，先注册，故而先执行。要改变二者的执行顺序，只需要改变两段源码的顺序即可。 W3C 规范：Next, the implementation must determine the current target’s candidate event listeners. This must be the list of all event listeners that have been registered on the current target in their order of registration. [HTML5] defines the ordering of listeners registered through event handler attributes. Once determined, the candidate event listeners must not be changed. Adding or removing listeners does not affect the current target’s candidate event listeners. 见： https://stackoverflow.com/questions/18103391/usecapture-in-addeventlistener-behaves-strangely?lq=1 https://stackoverflow.com/questions/11841330/event-listeners-registered-for-capturing-phase-not-triggered-before-bubbling-w 欢迎指正。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhukejin.com/categories/JavaScript/"}],"tags":[]},{"title":"甲午年己巳月末作","slug":"甲午年己巳月末作","date":"un22fin22","updated":"un00fin00","comments":true,"path":"2014/甲午年己巳月末作/","permalink":"https://zhukejin.com/2014/%E7%94%B2%E5%8D%88%E5%B9%B4%E5%B7%B1%E5%B7%B3%E6%9C%88%E6%9C%AB%E4%BD%9C/","excerpt":"","text":"序言：有赵氏彦超者，自言高祖桂枝。年方双十余四，观如暮色苍苍，形同槁木，无有复出。尝混迹于豫中，今迷途与沪上。或痴逝者，跋扈与斯夫；或迷来往，鄙薄于析疑。码三载而不知春秋所以，妄求凰而不展翅游历。图精诚以新声代故，奈何篱下兮以彼物代新。每每忧愁幽思，处处拊膺长叹，本天性疲软，亦难搏起雄风，故奋力而无始，无始而无果，无果而无终。故题词与之，其词曰： 赵家有子为贵胄，剑眉云鬓携星眸。本应跋扈为骄子，不遂难成万户侯。金玉不为草木生，草木何为金玉留。徒抚碗著空度日，归尘终究使人愁。 甲午年 己巳月 戊戌日（四月二十九）","categories":[{"name":"Verses","slug":"Verses","permalink":"https://zhukejin.com/categories/Verses/"}],"tags":[]},{"title":"2013年 30个实用的 Javascript 库","slug":"2013-better-jslibs","date":"un00fin00","updated":"un00fin00","comments":true,"path":"2013/2013-better-jslibs/","permalink":"https://zhukejin.com/2013/2013-better-jslibs/","excerpt":"原文 ： http://www.admin10000.com/document/4929.html Blast.js Blast.js通过字母、单词或是句子来分隔一段文本，这样你就可以把动画和样式注入到文本中。 Intense Images Intense Images是一个可以让用户全屏查看原像素照片的javascript库，高质量的照片大小一般不只有电脑屏幕这么大，它提供我们滑动查看，效果非常完美。 Hammer.js Hammer.js可以为你的网站添加触摸手势，是一个多点触摸手势库，能够为网页加入Tap、Double Tap、Swipe、Hold、Pinch、Drag等多点触摸事件，免去自己监听底层touchstart、touchmove、touchend事件并且写一大堆判断逻辑的痛苦。 epoch Epoch是一个生成实时图表的javascript库，它专注于可视化编程的两个方面：为历史数据创建图表和实时的数据图表可视化显示。 Boba.js Boba.js是一个易扩展的javascript库，它可以让添加谷歌统计变得简单，它不仅支持经典的ga.js库，而且支持新生的analytics.js，而且它有一个很酷的功能——trackLinks，trackLinks可以跟踪所有的子页面。","text":"原文 ： http://www.admin10000.com/document/4929.html Blast.js Blast.js通过字母、单词或是句子来分隔一段文本，这样你就可以把动画和样式注入到文本中。 Intense Images Intense Images是一个可以让用户全屏查看原像素照片的javascript库，高质量的照片大小一般不只有电脑屏幕这么大，它提供我们滑动查看，效果非常完美。 Hammer.js Hammer.js可以为你的网站添加触摸手势，是一个多点触摸手势库，能够为网页加入Tap、Double Tap、Swipe、Hold、Pinch、Drag等多点触摸事件，免去自己监听底层touchstart、touchmove、touchend事件并且写一大堆判断逻辑的痛苦。 epoch Epoch是一个生成实时图表的javascript库，它专注于可视化编程的两个方面：为历史数据创建图表和实时的数据图表可视化显示。 Boba.js Boba.js是一个易扩展的javascript库，它可以让添加谷歌统计变得简单，它不仅支持经典的ga.js库，而且支持新生的analytics.js，而且它有一个很酷的功能——trackLinks，trackLinks可以跟踪所有的子页面。 Lazy.js Lazy.js和Underscore和Lo-Dash的功能很像，但是有一个重要的区别：它是延迟执行的，它可以在大多数情景下展示出很好的性能，尤其是在解决大型数组的时候。 jscapture JSCapture是用纯JavaScript和HTML5写的屏蔽录制库。它允许你通过你的浏览器对桌面进行截图或录制，它使用getUserMedia来进行屏蔽捕捉，目前它只支持Chrome浏览器。 App.js App.js是一个轻量级的JavaScript UI库，因为它有一个好名字，现在它已经算是一个明星库了，它可以为你的网站生成一个用户体验很好的手机应用，完全不会影响到性能。而且它是跨平台的，支持Android 2.2以上版本和IOS 4.3以上版本。 Shepherd Shepherd是一个为应用创建用户指南的javascript库。它用到了另外一个开源的库——Tether。Tether可以确保用户指南不会受到浏览器布局的影响。目前Shepherd支持IE9以上和其它所有的现代浏览器。 RulersGuide.js RulersGuides.js是一个类似PhotoShop标尺的javascript库。 seen.js Seen.js渲染3D场景为SVG或者HTML Canvas。Seen.js包含对于SVG和HTML5 Canvas元素的图形功能的简单抽象。所以这个库的其它组件都是不用关心要渲染类型的。 At.Js At.js 是一个自动完成库，用来实现自动完成的提示，如表情等，就像你在 Github 或 Twitter 上看到的一样。它支持 HTML5 contentEditable 元素。你可以监听任何字符，而不仅仅是 ‘@’ 符号，可为不同的字符设置多个监听器以实现不同的行为和数据。 IBounce.js bounce.js 是一个用于制作漂亮的 CSS3 关键帧动画的 JavaScript 库，使用其特有的方式生成的动画效果。只需添加一个组件，选择预设，然后你就可以得到一个短网址或者导出为 CSS 代码。 Vis.js Vis.js 是一个动态的，基于浏览器的可视化库。该库被设计为易于使用，能处理大量的动态数据。该库由以下几部分组成：一是数据集和数据视图，基于灵活的键&#x2F;值数据集，可以添加，更新和删除项目，订阅数据集变化；二是时间轴，用于显示不同类型的时间轴数据，在时间轴上项目可以交互移动，缩放和操纵；三是图形，使用节点和边显示一个交互式图形或网络。 shine.js Shine.js 是一个用于实现漂亮阴影的 JavaScript 库。您可以设置动态光的位置，可定制的阴影。不依赖于第三方库，兼容 AMD。能在支持 textShadow 或 boxShadow 的浏览器中正常使用，如果有需要会自动添加前缀。 gremlins.js Gremlins.js 是基于 JavaScript 编写的 Monkey 测试库，支持 Node.js 平台和浏览器中使用。Gremlins.js 随机模拟用户操作：单击窗口中的任意位置，在表格中输入随机数据，或者将鼠标移动到特别的元素。Gremlins.j 的目的是触发 JavaScript 错误或使应用程序失败。如果它不能让你应用程序崩溃，那么说明你的应用程序已经足够强大了，可以发布给真正的用户使用。 contour.js Contour是Forio的可视化库提供的一个核心的通用库。建立于受欢迎的D3引擎之上，它可以让你很容易的建立一个可视化的数据图形。 stickerjs Sticker.js 是一个很小的 JavaScript 库，它允许您在网页中创建漂亮的贴纸效果。没有依赖关系（不需要 jQuery），可以在大多数支持 CSS3 的主流浏览器工作。 fattable.js Fattable是一个帮助创建无限滚动，及其无限行列数的Javascript类库。比较大的表（多余10000个单元格）使用DOM处理不是很方便。你的滚动会变得不均匀。同时比较大的表格增长的速度也更快。不太可能让用户去下载或者保留全部数据。Fattable可以帮助你很好的处理异步数据加载 cutjs CutJS是一个帮助你开发高性能，动态互动2DHTML5图形的超迷类库。支持现代浏览器和移动设备，可以帮助你开发游戏和可视化的应用。CutJS提供了DOM类型的API来创建和播放基于画布的图形。 grid.js GridList是一个二维的可拖拉的响应式列表库。 fn.js fn.js是一个鼓励你使用函数编程风格的可选Javascript类库。主要帮助你基于性能和规则来支持函数化实践。为了保证你的路径正确。fn.js内部强制避免side effects，Object Mutation和Function state。支持Node.js或者浏览器，可以使用常规的script来引用或者通过AMD加载器，例如，RequireJS。即将支持Bower。fn.js基于MIT LIcensed，你可以在Github下载 progress.js Progress.js是一个帮助开发人员使用JS和CSS3创建进度条的javascript类库。你可以自己设计进度条的模板或者自定义。你可以使用progess.js来展示加载内容的进度（images，Video等等），可以应用到所有页面元素，比如，textbox，textarea甚至整个body IBounce.js bounce.js 是一个用于制作漂亮的 CSS3 关键帧动画的 JavaScript 库，使用其特有的方式生成的动画效果。只需添加一个组件，选择预设，然后你就可以得到一个短网址或者导出为 CSS 代码。 instantclick.js 用来帮助你实现网站提速的Javascript类库，能够帮助导航更加高效。它预加载你的用户可能会点击的一些链接。可以配置来在特定操作下加载，例如，mousedown WOW.js 帮助你在滚动过程中展示CSS动画效果。缺省你可以用它来触发animate.css动画。当然，你可以配置来触发其他你喜欢使用的动画类库 Type Rendering Mix Type Rendering Mix是个基于浏览器、应用CSS文本渲染的引擎。Type Rendering Mix通过解析用户代理字符串检测浏览器的文本rasterizer和antialiasing方法。 scrollrevealjs ScrollReveal.js 用于创建和管理元素进入可视区域时的动画效果，帮助你的网站增加吸引力。只需要给元素增加 data-scrollreveal 属性，当元素进入可视区域的时候会自动被触发设置好的动画 switchery.js Switchery是个简单的JavaScript组件，只要几个简单的步骤就可以帮助用户把默认的HTML复选框转换成漂亮iOS 7样式风格。用户可以很方便的自定义这种转换，所以可以很好的配合你的设计风格。 echo.js Echo.js 是一个独立的延迟加载图片的 JavaScript 插件。Echo.js 不依赖第三方库，压缩后不到1KB大小。 延迟加载是提高网页首屏显示速度的一种很有效的方法，当图片元素进入窗口可视区域的时候，它就会改变图像的 src 属性，从服务端加载所需的图片，这也是一个异步的过程。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhukejin.com/categories/JavaScript/"}],"tags":[]},{"title":"凤凰游","slug":"凤凰游","date":"un55fin55","updated":"un00fin00","comments":true,"path":"2013/凤凰游/","permalink":"https://zhukejin.com/2013/%E5%87%A4%E5%87%B0%E6%B8%B8/","excerpt":"","text":"2013 年游至凤凰古城所作 暮辞大庸凤凰游寄舟抚缘泛中流两岸丝竹声声慢一纸锦书事事休","categories":[{"name":"Verses","slug":"Verses","permalink":"https://zhukejin.com/categories/Verses/"}],"tags":[]},{"title":"大庸游","slug":"大庸游","date":"un33fin33","updated":"un00fin00","comments":true,"path":"2013/大庸游/","permalink":"https://zhukejin.com/2013/%E5%A4%A7%E5%BA%B8%E6%B8%B8/","excerpt":"","text":"2013 年底辞去工作，游至张家界所作 几朝梦楚地，今可大庸游。斜渡洞庭湖，途径月明洲。千重雾锁绿不尽，一潭江水碧如秋。极乐降下普禅寺，瑶池淌来甘露流。好为山水谣，故从古人旅。武陵源在桃花溪，天子山上无天子。明君已逝凌太虚，北望朝野如青泥。四海云簇点将台，不见向王执御笔。何当共生鸿鹄志，斩却白龙树旌旗。","categories":[{"name":"Verses","slug":"Verses","permalink":"https://zhukejin.com/categories/Verses/"}],"tags":[]},{"title":"癸巳年正月末作(二)","slug":"癸巳年正月末作(二)","date":"un22fin22","updated":"un00fin00","comments":true,"path":"2013/癸巳年正月末作(二)/","permalink":"https://zhukejin.com/2013/%E7%99%B8%E5%B7%B3%E5%B9%B4%E6%AD%A3%E6%9C%88%E6%9C%AB%E4%BD%9C(%E4%BA%8C)/","excerpt":"","text":"昨日冬寒褪，今晨春暖来。绿荫晴人面，一树繁花开。踏青走无路，欲览时不待。无望隐于市，何能舒我怀？","categories":[{"name":"Verses","slug":"Verses","permalink":"https://zhukejin.com/categories/Verses/"}],"tags":[]},{"title":"癸巳年正月末作(一)","slug":"癸巳年正月末作(一)","date":"un22fin22","updated":"un00fin00","comments":true,"path":"2013/癸巳年正月末作(一)/","permalink":"https://zhukejin.com/2013/%E7%99%B8%E5%B7%B3%E5%B9%B4%E6%AD%A3%E6%9C%88%E6%9C%AB%E4%BD%9C(%E4%B8%80)/","excerpt":"","text":"时时劳案拂我意日日高歌舒我心不愿屈身泥淖中欲览春华净我尘","categories":[{"name":"Verses","slug":"Verses","permalink":"https://zhukejin.com/categories/Verses/"}],"tags":[]},{"title":"小令","slug":"小令·一","date":"un55fin55","updated":"un00fin00","comments":true,"path":"2013/小令·一/","permalink":"https://zhukejin.com/2013/%E5%B0%8F%E4%BB%A4%C2%B7%E4%B8%80/","excerpt":"","text":"《其一》 雨打窗扉开思君深彻怀辗转又踟蹰不敢邀君来 《其二》 吾爱青钢剑宁折不肯弯我心亦如此最忌畏人言","categories":[{"name":"Verses","slug":"Verses","permalink":"https://zhukejin.com/categories/Verses/"}],"tags":[]},{"title":"九月十一酒后，神游词(一)","slug":"九月十一酒后，神游词-一","date":"un44fin44","updated":"un00fin00","comments":true,"path":"2012/九月十一酒后，神游词-一/","permalink":"https://zhukejin.com/2012/%E4%B9%9D%E6%9C%88%E5%8D%81%E4%B8%80%E9%85%92%E5%90%8E%EF%BC%8C%E7%A5%9E%E6%B8%B8%E8%AF%8D-%E4%B8%80/","excerpt":"","text":"悦人乎，悦乎人？曲不为己身，词为诸公吟。而今同坐碧水滨，筑荷盖以褪秋尘。君有数斗酒，吾奏三尺琴。长行乐兮安我心，渡仙人兮动我魂。魂随飞鸟越南天，青鸾白鹤碧海边。纵有仙人抚我顶，不见结发授长生。","categories":[{"name":"Verses","slug":"Verses","permalink":"https://zhukejin.com/categories/Verses/"}],"tags":[]},{"title":"醉花阴","slug":"醉花阴","date":"un44fin44","updated":"un00fin00","comments":true,"path":"2012/醉花阴/","permalink":"https://zhukejin.com/2012/%E9%86%89%E8%8A%B1%E9%98%B4/","excerpt":"","text":"一霎微雨洒庭轩，惊醒始觉寒。 枉自心索乱，思君不在，度日亦如年。 晓来凝神倚窗畔，徒然添愁颜。 锦书寄飞鸿，故人难聚。 抱影初无眠。","categories":[{"name":"Verses","slug":"Verses","permalink":"https://zhukejin.com/categories/Verses/"}],"tags":[]},{"title":"拟陈情表","slug":"拟陈情表","date":"un11fin11","updated":"un00fin00","comments":true,"path":"2009/拟陈情表/","permalink":"https://zhukejin.com/2009/%E6%8B%9F%E9%99%88%E6%83%85%E8%A1%A8/","excerpt":"","text":"09年高中复读时所作 首山之阳，湛水之北。穷乡僻壤，无有甚者。故天降瑞华，诏余生也。 亲慎推度，赐名轲瑾。名微无字，自号无为。见诚不足方丈，闻实不足百里。孤陋寡闻，且不多言。 余幼时多疾，亲慎抚养。堪堪虚长，尽欺华年。尝习实高，本图通顺，不羁学旅。 然世事多舛，瞬息万变。昔日失足，今朝悔矣！心知逝者如斯夫，时过如箭出。诚不可复矣。 幸闻襄高之宏名，欲求来年之显赫，故自托此地，以慰双亲之薄愿。 今端坐于襄高，听讲师之授业，念旧友之皆去，感吾神之战栗。 每每处心积虑，忧愁忧思，常欲击盆而歌曰：“复读路途艰，世道人情险。同窗执子皆离去，吾坐樊笼又一年。可怜惊梦魂飞远，大学如花隔云端。” 尝闻孟母三迁而求一邻，吾今效之而感同窗之厚德。 在中坐下皆乃豪英，庆幸哉！吾结谢家之宝树耳。 自此犹知，世有大道。物竞天择，适者生存。我欲乘风凌五岳，又岂甘为污淖儿？ 遂再歌曰：古有囊萤复映雪，悬梁刺骨有先贤。宝剑锋严经磨炼，梅花香须历苦寒。 嗟夫！感怀零涕，情不自禁。挥手一文，徒自聊耳。本无俊秀之才，岂敢空忆谢将军耶？","categories":[{"name":"Verses","slug":"Verses","permalink":"https://zhukejin.com/categories/Verses/"}],"tags":[]},{"title":"拟行路难(二)","slug":"拟行路难-二","date":"un11fin11","updated":"un00fin00","comments":true,"path":"2009/拟行路难-二/","permalink":"https://zhukejin.com/2009/%E6%8B%9F%E8%A1%8C%E8%B7%AF%E9%9A%BE-%E4%BA%8C/","excerpt":"","text":"09年高中复读时所作 有口不能言，挥笔难成篇。 可叹胸中无城府，何处大道如青天？ 同窗挚子皆离去，吾坐樊笼又一年。 欲驾一叶游沧海，无奈身后事万千。 君不见心中有苦诉不得，高堂之令重如山。 复读路途艰，世道人情险。 可怜惊梦魂飞远，大学如花隔云端。 皆云囊萤复映雪，悬梁刺股有先贤。 宝剑锋严经磨炼，梅花香须历苦寒。 嗟夫！行路难！行路难！","categories":[{"name":"Verses","slug":"Verses","permalink":"https://zhukejin.com/categories/Verses/"}],"tags":[]},{"title":"戏为完美句","slug":"戏为完美句","date":"un33fin33","updated":"un00fin00","comments":true,"path":"2009/戏为完美句/","permalink":"https://zhukejin.com/2009/%E6%88%8F%E4%B8%BA%E5%AE%8C%E7%BE%8E%E5%8F%A5/","excerpt":"","text":"高中二年级沉迷网络游戏《完美世界》遂作 《其一》杖指河山三万里，尽处潋滟千波。素月分辉，明江共影，花醉三千客。应念夜雨十年灯，孤光残照，一笑大江横。谁道肝胆皆冰雪，苍云横渡，血染夕阳红。 《其二》看世间森罗万相，八荒六合，谁诉离殇？只识金戈射日忙。轰雷天罪，群魔乱舞，修罗炼狱谁敢书。笑谈秦皇可诛天，浮华背后，风云舒卷。孰知血战非我愿！弃屠刀，焚业火，立地成佛！","categories":[{"name":"Verses","slug":"Verses","permalink":"https://zhukejin.com/categories/Verses/"}],"tags":[]}],"categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhukejin.com/categories/JavaScript/"},{"name":"Python","slug":"Python","permalink":"https://zhukejin.com/categories/Python/"},{"name":"Other","slug":"Other","permalink":"https://zhukejin.com/categories/Other/"},{"name":"CSS","slug":"CSS","permalink":"https://zhukejin.com/categories/CSS/"},{"name":"Verses","slug":"Verses","permalink":"https://zhukejin.com/categories/Verses/"}],"tags":[{"name":"Typescript","slug":"Typescript","permalink":"https://zhukejin.com/tags/Typescript/"},{"name":"Tool","slug":"Tool","permalink":"https://zhukejin.com/tags/Tool/"},{"name":"LESS","slug":"LESS","permalink":"https://zhukejin.com/tags/LESS/"},{"name":"tnt","slug":"tnt","permalink":"https://zhukejin.com/tags/tnt/"},{"name":"NPM","slug":"NPM","permalink":"https://zhukejin.com/tags/NPM/"},{"name":"Design","slug":"Design","permalink":"https://zhukejin.com/tags/Design/"},{"name":"RxJS","slug":"RxJS","permalink":"https://zhukejin.com/tags/RxJS/"},{"name":"Git","slug":"Git","permalink":"https://zhukejin.com/tags/Git/"},{"name":"Angular","slug":"Angular","permalink":"https://zhukejin.com/tags/Angular/"},{"name":"ARTS","slug":"ARTS","permalink":"https://zhukejin.com/tags/ARTS/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://zhukejin.com/tags/Algorithm/"},{"name":"hexo","slug":"hexo","permalink":"https://zhukejin.com/tags/hexo/"},{"name":"SASS","slug":"SASS","permalink":"https://zhukejin.com/tags/SASS/"},{"name":"React","slug":"React","permalink":"https://zhukejin.com/tags/React/"},{"name":"Webpack","slug":"Webpack","permalink":"https://zhukejin.com/tags/Webpack/"},{"name":"HighCharts","slug":"HighCharts","permalink":"https://zhukejin.com/tags/HighCharts/"}]}